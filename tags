!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
API	deps/maru/lib/maru/helper.ex	/^      defmodule API do$/;"	m
Adapter	deps/plug/lib/plug/conn/adapter.ex	/^defmodule Plug.Conn.Adapter do$/;"	m
AllowBlank	deps/maru/lib/maru/validations.ex	/^  defmodule AllowBlank do$/;"	m
AlreadySentError	deps/plug/lib/plug/conn.ex	/^  defmodule AlreadySentError do$/;"	m
AppRouter	deps/plug/lib/plug/error_handler.ex	/^      defmodule AppRouter do$/;"	m
AppRouter	deps/plug/lib/plug/router.ex	/^      defmodule AppRouter do$/;"	m
AtLeastOneOf	deps/maru/lib/maru/validations.ex	/^  defmodule AtLeastOneOf do$/;"	m
Atom	deps/maru/lib/maru/param_type.ex	/^  defmodule Atom do$/;"	m
Authorization	deps/maru/lib/maru/helper.ex	/^    defmodule Authorization do$/;"	m
BadEncodingError	deps/plug/lib/plug/parsers.ex	/^  defmodule BadEncodingError do$/;"	m
Boolean	deps/maru/lib/maru/param_type.ex	/^  defmodule Boolean do$/;"	m
Builder	deps/maru/lib/maru/builder.ex	/^defmodule Maru.Builder do$/;"	m
Builder	deps/plug/lib/plug/builder.ex	/^defmodule Plug.Builder do$/;"	m
COOKIE	deps/plug/lib/plug/session/cookie.ex	/^defmodule Plug.Session.COOKIE do$/;"	m
CSRFProtection	deps/plug/lib/plug/csrf_protection.ex	/^defmodule Plug.CSRFProtection do$/;"	m
CharList	deps/maru/lib/maru/param_type.ex	/^  defmodule CharList do$/;"	m
Collectable	deps/plug/lib/plug/conn.ex	/^defimpl Collectable, for: Plug.Conn do$/;"	i
Config	deps/maru/lib/maru/config.ex	/^defmodule Maru.Config do$/;"	m
Conn	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^defmodule Plug.Adapters.Cowboy.Conn do$/;"	m
Conn	deps/plug/lib/plug/adapters/test/conn.ex	/^defmodule Plug.Adapters.Test.Conn do$/;"	m
Conn	deps/plug/lib/plug/conn.ex	/^defmodule Plug.Conn do$/;"	m
Cookies	deps/plug/lib/plug/conn/cookies.ex	/^defmodule Plug.Conn.Cookies do$/;"	m
Cowboy	deps/plug/lib/plug/adapters/cowboy.ex	/^defmodule Plug.Adapters.Cowboy do$/;"	m
Crypto	deps/plug/lib/plug/crypto.ex	/^defmodule Plug.Crypto do$/;"	m
DSLs	deps/maru/lib/maru/builder/dsls.ex	/^defmodule Maru.Builder.DSLs do$/;"	m
Debugger	deps/plug/lib/plug/debugger.ex	/^defmodule Plug.Debugger do$/;"	m
Decode	deps/poison/lib/poison/decoder.ex	/^defmodule Poison.Decode do$/;"	m
Decoder	deps/poison/lib/poison/decoder.ex	/^defimpl Poison.Decoder, for: Any do$/;"	i
Decoder	deps/poison/lib/poison/decoder.ex	/^defprotocol Poison.Decoder do$/;"	p
Dispatcher	lib/leanpoker_elixir/dispatcher.ex	/^defmodule LeanpokerElixir.Dispatcher do$/;"	m
ETS	deps/plug/lib/plug/session/ets.ex	/^defmodule Plug.Session.ETS do$/;"	m
Encode	deps/poison/lib/poison/encoder.ex	/^defmodule Poison.Encode do$/;"	m
EncodeError	deps/poison/lib/poison/encoder.ex	/^defmodule Poison.EncodeError do$/;"	m
Encoder	deps/poison/lib/poison/encoder.ex	/^      defimpl Poison.Encoder, for: unquote(module) do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: Any do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: Atom do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: BitString do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: Float do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: HashDict do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: Integer do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: List do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: Map do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defimpl Poison.Encoder, for: [Range, Stream, HashSet] do$/;"	i
Encoder	deps/poison/lib/poison/encoder.ex	/^defprotocol Poison.Encoder do$/;"	p
Endpoint	deps/maru/lib/maru/router/endpoint.ex	/^defmodule Maru.Router.Endpoint do$/;"	m
ErrorHandler	deps/plug/lib/plug/error_handler.ex	/^defmodule Plug.ErrorHandler do$/;"	m
ExactlyOneOf	deps/maru/lib/maru/validations.ex	/^  defmodule ExactlyOneOf do$/;"	m
Exception	deps/plug/lib/plug/exceptions.ex	/^defimpl Plug.Exception, for: Any do$/;"	i
Exception	deps/plug/lib/plug/exceptions.ex	/^defprotocol Plug.Exception do$/;"	p
Exceptions	deps/maru/lib/maru/builder/exceptions.ex	/^defmodule Maru.Builder.Exceptions do$/;"	m
Exceptions	deps/maru/lib/maru/exceptions.ex	/^defmodule Maru.Exceptions do$/;"	m
Extend	deps/maru/lib/maru/plugs/extend.ex	/^defmodule Maru.Plugs.Extend do$/;"	m
File	deps/maru/lib/maru/param_type.ex	/^  defmodule File do$/;"	m
Float	deps/maru/lib/maru/param_type.ex	/^  defmodule Float do$/;"	m
HTML	deps/plug/lib/plug/html.ex	/^defmodule Plug.HTML do$/;"	m
Handler	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^defmodule Plug.Adapters.Cowboy.Handler do$/;"	m
Head	deps/plug/lib/plug/head.ex	/^defmodule Plug.Head do$/;"	m
Helper	deps/maru/lib/maru/helper.ex	/^defmodule Maru.Helper do$/;"	m
Inspect	deps/plug/lib/plug/conn.ex	/^defimpl Inspect, for: Plug.Conn do$/;"	i
Integer	deps/maru/lib/maru/param_type.ex	/^  defmodule Integer do$/;"	m
InvalidCSRFTokenError	deps/plug/lib/plug/csrf_protection.ex	/^  defmodule InvalidCSRFTokenError do$/;"	m
InvalidCrossOriginRequestError	deps/plug/lib/plug/csrf_protection.ex	/^  defmodule InvalidCrossOriginRequestError do$/;"	m
InvalidFormatter	deps/maru/lib/maru/exceptions.ex	/^  defmodule InvalidFormatter do$/;"	m
InvalidHeaderKeyFormatError	deps/plug/lib/plug/conn.ex	/^  defmodule InvalidHeaderKeyFormatError do$/;"	m
InvalidPathError	deps/plug/lib/plug/static.ex	/^  defmodule InvalidPathError do$/;"	m
InvalidSpecError	deps/plug/lib/plug/router/utils.ex	/^defmodule Plug.Router.InvalidSpecError do$/;"	m
JSON	deps/plug/lib/plug/parsers/json.ex	/^defmodule Plug.Parsers.JSON do$/;"	m
JSONHeaderPlug	deps/plug/lib/plug.ex	/^      defmodule JSONHeaderPlug do$/;"	m
KeyGenerator	deps/plug/lib/plug/crypto/key_generator.ex	/^defmodule Plug.Crypto.KeyGenerator do$/;"	m
LeanpokerElixir	lib/leanpoker_elixir.ex	/^defmodule LeanpokerElixir do$/;"	m
LeanpokerElixirTest	test/leanpoker_elixir_test.exs	/^defmodule LeanpokerElixirTest do$/;"	m
List	deps/maru/lib/maru/param_type.ex	/^  defmodule List do$/;"	m
Logger	deps/plug/lib/plug/logger.ex	/^defmodule Plug.Logger do$/;"	m
MIME	deps/plug/lib/plug/mime.ex	/^defmodule Plug.MIME do$/;"	m
MULTIPART	deps/plug/lib/plug/parsers/multipart.ex	/^defmodule Plug.Parsers.MULTIPART do$/;"	m
Map	deps/maru/lib/maru/param_type.ex	/^  defmodule Map do$/;"	m
Maru	deps/maru/lib/maru.ex	/^defmodule Maru do$/;"	m
MessageEncryptor	deps/plug/lib/plug/crypto/message_encryptor.ex	/^defmodule Plug.Crypto.MessageEncryptor do$/;"	m
MessageVerifier	deps/plug/lib/plug/crypto/message_verifier.ex	/^defmodule Plug.Crypto.MessageVerifier do$/;"	m
MethodNotAllow	deps/maru/lib/maru/exceptions.ex	/^  defmodule MethodNotAllow do$/;"	m
MethodOverride	deps/plug/lib/plug/method_override.ex	/^defmodule Plug.MethodOverride do$/;"	m
Methods	deps/maru/lib/maru/builder/methods.ex	/^defmodule Maru.Builder.Methods do$/;"	m
Middleware	deps/maru/lib/maru/middleware.ex	/^defmodule Maru.Middleware do$/;"	m
Mixfile	deps/maru/mix.exs	/^defmodule Maru.Mixfile do$/;"	m
Mixfile	deps/plug/mix.exs	/^defmodule Plug.Mixfile do$/;"	m
Mixfile	deps/poison/mix.exs	/^defmodule Poison.Mixfile do$/;"	m
Mixfile	mix.exs	/^defmodule LeanpokerElixir.Mixfile do$/;"	m
MutuallyExclusive	deps/maru/lib/maru/validations.ex	/^  defmodule MutuallyExclusive do$/;"	m
MyApp	deps/plug/lib/plug/builder.ex	/^      defmodule MyApp do$/;"	m
MyApp	deps/plug/lib/plug/debugger.ex	/^      defmodule MyApp do$/;"	m
MyPlug	deps/plug/lib/plug/static.ex	/^      defmodule MyPlug do$/;"	m
Namespaces	deps/maru/lib/maru/builder/namespaces.ex	/^defmodule Maru.Builder.Namespaces do$/;"	m
NotFound	deps/maru/lib/maru/exceptions.ex	/^  defmodule NotFound do$/;"	m
NotFound	deps/maru/lib/maru/plugs/notfound.ex	/^defmodule Maru.Plugs.NotFound do$/;"	m
NotSentError	deps/plug/lib/plug/conn.ex	/^  defmodule NotSentError do$/;"	m
Param	deps/maru/lib/maru/router.ex	/^  defmodule Param do$/;"	m
ParamType	deps/maru/lib/maru/param_type.ex	/^defmodule Maru.ParamType do$/;"	m
Params	deps/maru/lib/maru/builder/params.ex	/^defmodule Maru.Builder.Params do$/;"	m
Params	deps/maru/lib/maru/helpers/params.ex	/^defmodule Maru.Helpers.Params do$/;"	m
ParseError	deps/plug/lib/plug/parsers.ex	/^  defmodule ParseError do$/;"	m
Parser	deps/poison/lib/poison/parser.ex	/^defmodule Poison.Parser do$/;"	m
Parsers	deps/plug/lib/plug/parsers.ex	/^defmodule Plug.Parsers do$/;"	m
Path	deps/maru/lib/maru/router/path.ex	/^defmodule Maru.Router.Path do$/;"	m
Player	lib/leanpoker_elixir/player.ex	/^defmodule LeanpokerElixir.Player do$/;"	m
Plug	deps/plug/lib/plug.ex	/^defmodule Plug do$/;"	m
PlugUsingHalt	deps/plug/lib/plug/builder.ex	/^      defmodule PlugUsingHalt do$/;"	m
PlugWithCustomCall	deps/plug/lib/plug/builder.ex	/^      defmodule PlugWithCustomCall do$/;"	m
PlugWithCustomOptions	deps/plug/lib/plug/builder.ex	/^      defmodule PlugWithCustomOptions do$/;"	m
Poison	deps/poison/lib/poison.ex	/^defmodule Poison do$/;"	m
Prepare	deps/maru/lib/maru/plugs/prepare.ex	/^defmodule Maru.Plugs.Prepare do$/;"	m
Pretty	deps/poison/lib/poison/encoder.ex	/^defmodule Poison.Pretty do$/;"	m
Query	deps/plug/lib/plug/conn/query.ex	/^defmodule Plug.Conn.Query do$/;"	m
Regexp	deps/maru/lib/maru/validations.ex	/^  defmodule Regexp do$/;"	m
RequestId	deps/plug/lib/plug/request_id.ex	/^defmodule Plug.RequestId do$/;"	m
RequestTooLargeError	deps/plug/lib/plug/parsers.ex	/^  defmodule RequestTooLargeError do$/;"	m
Resource	deps/maru/lib/maru/router.ex	/^  defmodule Resource do$/;"	m
Response	deps/maru/lib/maru/helpers/response.ex	/^defmodule Maru.Helpers.Response do$/;"	m
Response	deps/maru/lib/maru/response.ex	/^defimpl Maru.Response, for: Any do$/;"	i
Response	deps/maru/lib/maru/response.ex	/^defimpl Maru.Response, for: BitString do$/;"	i
Response	deps/maru/lib/maru/response.ex	/^defprotocol Maru.Response do$/;"	p
Router	deps/maru/lib/maru/plugs/router.ex	/^defmodule Maru.Plugs.Router do$/;"	m
Router	deps/maru/lib/maru/router.ex	/^defmodule Maru.Router do$/;"	m
Router	deps/plug/lib/plug/router.ex	/^defmodule Plug.Router do$/;"	m
Routers	deps/maru/lib/maru/builder/routers.ex	/^defmodule Maru.Builder.Routers do$/;"	m
Routers	deps/maru/lib/mix/tasks/routers.ex	/^defmodule Mix.Tasks.Maru.Routers do$/;"	m
SSL	deps/plug/lib/plug/ssl.ex	/^defmodule Plug.SSL do$/;"	m
Session	deps/plug/lib/plug/session.ex	/^defmodule Plug.Session do$/;"	m
SharedParams	deps/maru/lib/maru/helper.ex	/^      defmodule SharedParams do$/;"	m
Static	deps/plug/lib/plug/static.ex	/^defmodule Plug.Static do$/;"	m
Status	deps/plug/lib/plug/conn/status.ex	/^defmodule Plug.Conn.Status do$/;"	m
Store	deps/plug/lib/plug/session/store.ex	/^defmodule Plug.Session.Store do$/;"	m
String	deps/maru/lib/maru/param_type.ex	/^  defmodule String do$/;"	m
Supervisor	deps/plug/lib/plug/supervisor.ex	/^defmodule Plug.Supervisor do$/;"	m
SyntaxError	deps/poison/lib/poison/parser.ex	/^defmodule Poison.SyntaxError do$/;"	m
Term	deps/maru/lib/maru/param_type.ex	/^  defmodule Term do$/;"	m
Test	deps/maru/lib/maru/test.ex	/^defmodule Maru.Test do$/;"	m
Test	deps/plug/lib/plug/test.ex	/^defmodule Plug.Test do$/;"	m
Translator	deps/plug/lib/plug/adapters/translator.ex	/^defmodule Plug.Adapters.Translator do$/;"	m
URLENCODED	deps/plug/lib/plug/parsers/urlencoded.ex	/^defmodule Plug.Parsers.URLENCODED do$/;"	m
UndefinedValidator	deps/maru/lib/maru/exceptions.ex	/^  defmodule UndefinedValidator do$/;"	m
Unfetched	deps/plug/lib/plug/conn/unfetched.ex	/^defmodule Plug.Conn.Unfetched do$/;"	m
UnsupportedMediaTypeError	deps/plug/lib/plug/parsers.ex	/^  defmodule UnsupportedMediaTypeError do$/;"	m
Upload	deps/plug/lib/plug/upload.ex	/^defmodule Plug.Upload do$/;"	m
Utils	deps/maru/lib/maru/utils.ex	/^defmodule Maru.Utils do$/;"	m
Utils	deps/plug/lib/plug/conn/utils.ex	/^defmodule Plug.Conn.Utils do$/;"	m
Utils	deps/plug/lib/plug/router/utils.ex	/^defmodule Plug.Router.Utils do$/;"	m
Validation	deps/maru/lib/maru/exceptions.ex	/^  defmodule Validation do$/;"	m
Validations	deps/maru/lib/maru/validations.ex	/^defmodule Maru.Validations do$/;"	m
Validator	deps/maru/lib/maru/router.ex	/^  defmodule Validator do$/;"	m
Values	deps/maru/lib/maru/validations.ex	/^  defmodule Values do$/;"	m
Version	deps/maru/lib/maru/plugs/version.ex	/^defmodule Maru.Plugs.Version do$/;"	m
WrapperError	deps/plug/lib/plug/conn/wrapper_error.ex	/^defmodule Plug.Conn.WrapperError do$/;"	m
__before_compile__	deps/maru/lib/maru/builder.ex	/^  defmacro __before_compile__(%Macro.Env{module: module}=env) do$/;"	a
__before_compile__	deps/maru/lib/maru/helper.ex	/^  defmacro __before_compile__(%Macro.Env{module: module}) do$/;"	a
__before_compile__	deps/plug/lib/plug/builder.ex	/^  defmacro __before_compile__(env) do$/;"	a
__before_compile__	deps/plug/lib/plug/debugger.ex	/^  defmacro __before_compile__(_) do$/;"	a
__before_compile__	deps/plug/lib/plug/error_handler.ex	/^  defmacro __before_compile__(_env) do$/;"	a
__before_compile__	deps/plug/lib/plug/router.ex	/^  defmacro __before_compile__(_env) do$/;"	a
__catch__	deps/plug/lib/plug/debugger.ex	/^  def __catch__(_conn, :error, %Plug.Conn.WrapperError{} = wrapper, opts) do$/;"	f
__catch__	deps/plug/lib/plug/debugger.ex	/^  def __catch__(conn, kind, reason, opts) do$/;"	f
__catch__	deps/plug/lib/plug/debugger.ex	/^  defp __catch__(conn, kind, reason, stack, opts) do$/;"	f
__catch__	deps/plug/lib/plug/error_handler.ex	/^  def __catch__(_conn, :error, %Plug.Conn.WrapperError{} = wrapper, handle_errors) do$/;"	f
__catch__	deps/plug/lib/plug/error_handler.ex	/^  def __catch__(conn, kind, reason, handle_errors) do$/;"	f
__catch__	deps/plug/lib/plug/error_handler.ex	/^  defp __catch__(conn, kind, reason, stack, handle_errors) do$/;"	f
__deriving__	deps/poison/lib/poison/encoder.ex	/^  defmacro __deriving__(module, struct, options) do$/;"	a
__endpoints__	deps/maru/lib/maru/builder.ex	/^        def __endpoints__, do: @endpoints$/;"	f
__extend__	deps/maru/lib/maru/builder.ex	/^        def __extend__, do: @extend$/;"	f
__route__	deps/plug/lib/plug/router.ex	/^  def __route__(method, path, guards, options) do$/;"	f
__routers__	deps/maru/lib/maru/builder.ex	/^        def __routers__, do: @maru_router_plugs$/;"	f
__shared_params__	deps/maru/lib/maru/helper.ex	/^      def __shared_params__ do$/;"	f
__using__	deps/maru/lib/maru/builder.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/maru/lib/maru/helper.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/maru/lib/maru/helpers/response.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/maru/lib/maru/middleware.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/maru/lib/maru/router.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/maru/lib/maru/test.ex	/^  defmacro __using__(opts) do$/;"	a
__using__	deps/plug/lib/plug/builder.ex	/^  defmacro __using__(opts) do$/;"	a
__using__	deps/plug/lib/plug/debugger.ex	/^  defmacro __using__(opts) do$/;"	a
__using__	deps/plug/lib/plug/error_handler.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/plug/lib/plug/router.ex	/^  defmacro __using__(opts) do$/;"	a
__using__	deps/plug/lib/plug/test.ex	/^  defmacro __using__(_) do$/;"	a
__using__	deps/poison/lib/poison/encoder.ex	/^  defmacro __using__(_) do$/;"	a
__version__	deps/maru/lib/maru/builder.ex	/^        def __version__, do: @version$/;"	f
add_seconds	deps/plug/lib/plug/conn/cookies.ex	/^  defp add_seconds(time, seconds_to_add) do$/;"	f
allowed?	deps/plug/lib/plug/static.ex	/^  defp allowed?(_only, []),   do: false$/;"	f
allowed?	deps/plug/lib/plug/static.ex	/^  defp allowed?(nil, _list),  do: true$/;"	f
allowed?	deps/plug/lib/plug/static.ex	/^  defp allowed?(only, [h|_]), do: h in only$/;"	f
application	deps/maru/mix.exs	/^  def application do$/;"	f
application	deps/plug/mix.exs	/^  def application do$/;"	f
application	deps/poison/mix.exs	/^  def application do$/;"	f
application	mix.exs	/^  def application do$/;"	f
args	deps/plug/lib/plug/adapters/cowboy.ex	/^  def args(scheme, plug, opts, cowboy_options) do$/;"	f
array_values	deps/poison/lib/poison/parser.ex	/^  defp array_values("]" <> rest, _, []) do$/;"	f
array_values	deps/poison/lib/poison/parser.ex	/^  defp array_values(string, keys, acc) do$/;"	f
assert_ssl_options	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp assert_ssl_options(cowboy_options) do$/;"	f
assign	deps/maru/lib/maru/helpers/response.ex	/^  defmacro assign(key, value) do$/;"	a
assign	deps/plug/lib/plug/conn.ex	/^  def assign(%Conn{assigns: assigns} = conn, key, value) when is_atom(key) do$/;"	f
assign_list	deps/plug/lib/plug/conn/query.ex	/^  defp assign_list([], value), do: value$/;"	f
assign_list	deps/plug/lib/plug/conn/query.ex	/^  defp assign_list(t, current, value) do$/;"	f
assign_list	deps/plug/lib/plug/conn/query.ex	/^  defp assign_list(t, value),  do: assign_parts(t, value, %{})$/;"	f
assign_parts	deps/plug/lib/plug/conn/query.ex	/^  defp assign_parts([key,""|t], value, acc) do$/;"	f
assign_parts	deps/plug/lib/plug/conn/query.ex	/^  defp assign_parts([key], value, acc) do$/;"	f
assign_parts	deps/plug/lib/plug/conn/query.ex	/^  defp assign_parts([key|t], value, acc) do$/;"	f
async_assign	deps/plug/lib/plug/conn.ex	/^  def async_assign(%Conn{} = conn, key, fun) when is_atom(key) and is_function(fun, 0) do$/;"	f
await_assign	deps/plug/lib/plug/conn.ex	/^  def await_assign(%Conn{} = conn, key, timeout \\\\ 5000) when is_atom(key) do$/;"	f
before_send	deps/plug/lib/plug/session.ex	/^  defp before_send(sid, config) do$/;"	f
bet_request	lib/leanpoker_elixir/player.ex	/^  def bet_request(game_state) do$/;"	f
binary_to_identifier	deps/plug/lib/plug/router/utils.ex	/^  defp binary_to_identifier(prefix, <<letter, _::binary>> = binary)$/;"	f
binary_to_identifier	deps/plug/lib/plug/router/utils.ex	/^  defp binary_to_identifier(prefix, _) do$/;"	f
body_or_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp body_or_params(body, _query, headers) when is_binary(body) do$/;"	f
body_or_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp body_or_params(nil, _query, headers),$/;"	f
body_or_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp body_or_params(params, query, headers) when is_list(params) do$/;"	f
body_or_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp body_or_params(params, query, headers) when is_map(params) do$/;"	f
boom	deps/plug/lib/plug/debugger.ex	/^        def boom(conn, _) do$/;"	f
build_host_match	deps/plug/lib/plug/router/utils.ex	/^  def build_host_match(host) do$/;"	f
build_methods	deps/plug/lib/plug/router.ex	/^  defp build_methods([], guards) do$/;"	f
build_methods	deps/plug/lib/plug/router.ex	/^  defp build_methods([method], guards) do$/;"	f
build_methods	deps/plug/lib/plug/router.ex	/^  defp build_methods(methods, guards) do$/;"	f
build_path_match	deps/plug/lib/plug/router/utils.ex	/^  def build_path_match(spec, context \\\\ nil) when is_binary(spec) do$/;"	f
build_path_match	deps/plug/lib/plug/router/utils.ex	/^  defp build_path_match([], _context, vars, acc) do$/;"	f
build_path_match	deps/plug/lib/plug/router/utils.ex	/^  defp build_path_match([h|t], context, vars, acc) do$/;"	f
build_ref	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp build_ref(plug, scheme) do$/;"	f
call	deps/maru/lib/maru/builder.ex	/^        def call(var!(conn), opts) do$/;"	f
call	deps/maru/lib/maru/builder.ex	/^      def call(unquote(conn), _) do$/;"	f
call	deps/maru/lib/maru/middleware.ex	/^      def call(conn, _opts), do: conn$/;"	f
call	deps/maru/lib/maru/plugs/extend.ex	/^  def call(%Conn{method: method, private: %{maru_resource_path: path}}=conn, {router, _version, extend, nil, except}) do$/;"	f
call	deps/maru/lib/maru/plugs/extend.ex	/^  def call(%Conn{method: method, private: %{maru_resource_path: path}}=conn, {router, _version, extend, only, nil}) do$/;"	f
call	deps/maru/lib/maru/plugs/extend.ex	/^  def call(%Conn{private: %{maru_version: v1}}=conn, {_router, v2, _extend, _only, _except}) when v1 != v2 do$/;"	f
call	deps/maru/lib/maru/plugs/extend.ex	/^  def call(conn, {router, _version, extend, nil, nil}) do$/;"	f
call	deps/maru/lib/maru/plugs/notfound.ex	/^  def call(conn, _) do$/;"	f
call	deps/maru/lib/maru/plugs/prepare.ex	/^  def call(conn, []) do$/;"	f
call	deps/maru/lib/maru/plugs/router.ex	/^  def call(%Conn{private: %{maru_version: v1}}=conn_orig, {router, path, v2, param_context})$/;"	f
call	deps/maru/lib/maru/plugs/router.ex	/^  def call(conn, _) do$/;"	f
call	deps/maru/lib/maru/plugs/version.ex	/^  def call(conn, _) do$/;"	f
call	deps/maru/lib/maru/plugs/version.ex	/^  def call(conn, {:accept_version_header, _opts}) do$/;"	f
call	deps/maru/lib/maru/plugs/version.ex	/^  def call(conn, {:param, opts}) do$/;"	f
call	deps/maru/lib/maru/plugs/version.ex	/^  def call(conn, {:path, _opts}) do$/;"	f
call	deps/plug/lib/plug.ex	/^        def call(conn, _opts) do$/;"	f
call	deps/plug/lib/plug.ex	/^  defcallback call(Plug.Conn.t, opts) :: Plug.Conn.t$/;"	c
call	deps/plug/lib/plug/builder.ex	/^        def call(conn, _opts) do$/;"	f
call	deps/plug/lib/plug/builder.ex	/^      def call(conn, opts) do$/;"	f
call	deps/plug/lib/plug/csrf_protection.ex	/^  def call(conn, opts) do$/;"	f
call	deps/plug/lib/plug/debugger.ex	/^      def call(conn, opts) do$/;"	f
call	deps/plug/lib/plug/error_handler.ex	/^      def call(conn, opts) do$/;"	f
call	deps/plug/lib/plug/head.ex	/^  def call(%Conn{method: "HEAD"} = conn, []), do: %{conn | method: "GET"}$/;"	f
call	deps/plug/lib/plug/head.ex	/^  def call(conn, []), do: conn$/;"	f
call	deps/plug/lib/plug/logger.ex	/^  def call(conn, level) do$/;"	f
call	deps/plug/lib/plug/method_override.ex	/^  def call(%Plug.Conn{method: "POST", body_params: body_params} = conn, []),$/;"	f
call	deps/plug/lib/plug/method_override.ex	/^  def call(%Plug.Conn{} = conn, []),$/;"	f
call	deps/plug/lib/plug/parsers.ex	/^  def call(%Conn{body_params: %Plug.Conn.Unfetched{}} = conn, _opts) do$/;"	f
call	deps/plug/lib/plug/parsers.ex	/^  def call(%Conn{req_headers: req_headers, method: method,$/;"	f
call	deps/plug/lib/plug/parsers.ex	/^  def call(%Conn{} = conn, _opts) do$/;"	f
call	deps/plug/lib/plug/request_id.ex	/^  def call(conn, req_id_header) do$/;"	f
call	deps/plug/lib/plug/session.ex	/^  def call(conn, config) do$/;"	f
call	deps/plug/lib/plug/ssl.ex	/^  def call(conn, {hsts, host, rewrites}) do$/;"	f
call	deps/plug/lib/plug/static.ex	/^  def call(conn = %Conn{method: meth}, {at, from, gzip, qs_cache, et_cache, only, headers})$/;"	f
call	deps/plug/lib/plug/static.ex	/^  def call(conn, _opts) do$/;"	f
change_version	deps/maru/lib/maru/builder/routers.ex	/^  defp change_version(endpoint, version) do$/;"	f
check_param	deps/maru/lib/maru/router/endpoint.ex	/^  defp check_param(attr_name, value, param_context) do$/;"	f
check_param_context	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_param_context(%Conn{private: %{maru_param_context: _}}=conn), do: conn$/;"	f
check_param_context	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_param_context(conn), do: Conn.put_private(conn, :maru_param_context, [])$/;"	f
check_path	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_path(%Conn{private: %{maru_resource_path: _}}=conn), do: conn$/;"	f
check_path	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_path(conn), do: Conn.put_private(conn, :maru_resource_path, conn.path_info)$/;"	f
check_route_path	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_route_path(%Conn{private: %{maru_route_path: _}}=conn), do: conn$/;"	f
check_route_path	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_route_path(conn), do: Conn.put_private(conn, :maru_route_path, [])$/;"	f
check_serializer	deps/plug/lib/plug/session/cookie.ex	/^  defp check_serializer(_), do:$/;"	f
check_serializer	deps/plug/lib/plug/session/cookie.ex	/^  defp check_serializer(serializer) when is_atom(serializer), do: serializer$/;"	f
check_signing_salt	deps/plug/lib/plug/session/cookie.ex	/^  defp check_signing_salt(opts) do$/;"	f
check_version	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_version(%Conn{private: %{maru_version: _}}=conn), do: conn$/;"	f
check_version	deps/maru/lib/maru/plugs/prepare.ex	/^  defp check_version(conn), do: Conn.put_private(conn, :maru_version, nil)$/;"	f
child_spec	deps/plug/lib/plug/adapters/cowboy.ex	/^  def child_spec(scheme, plug, opts, cowboy_options \\\\ []) do$/;"	f
chunk	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def chunk(req, body) do$/;"	f
chunk	deps/plug/lib/plug/adapters/test/conn.ex	/^  def chunk(%{chunks: chunks} = state, body) do$/;"	f
chunk	deps/plug/lib/plug/adapters/test/conn.ex	/^  def chunk(%{method: "HEAD"} = state, _body),$/;"	f
chunk	deps/plug/lib/plug/conn.ex	/^  def chunk(%Conn{adapter: {adapter, payload}, state: :chunked} = conn, chunk) do$/;"	f
chunk	deps/plug/lib/plug/conn.ex	/^  def chunk(%Conn{}, chunk) when is_binary(chunk) or is_list(chunk) do$/;"	f
chunk	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback chunk(payload, Conn.status) ::$/;"	c
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size("", _, acc), do: acc$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<_ :: utf8>> <> _, :unicode, acc) do$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<char :: utf8>> <> _, :javascript, acc) when char in [0x2028, 0x2029] do$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<char>> <> _, _mode, acc) when char < 0x1F or char in '"\\\\' do$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<char>> <> rest, mode, acc) when char < 0x80 do$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<char>>, _, _) do$/;"	f
chunk_size	deps/poison/lib/poison/encoder.ex	/^  defp chunk_size(<<codepoint :: utf8>> <> rest, mode, acc) do$/;"	f
clear_session	deps/plug/lib/plug/conn.ex	/^  def clear_session(conn) do$/;"	f
code	deps/plug/lib/plug/conn/status.ex	/^    def code(unquote(atom)), do: unquote(code)$/;"	f
code	deps/plug/lib/plug/conn/status.ex	/^  def code(integer) when integer in 100..999 do$/;"	f
code	deps/plug/lib/plug/conn/status.ex	/^  def code(integer_or_atom)$/;"	f
compile	deps/plug/lib/plug/builder.ex	/^  def compile(env, pipeline, builder_opts) do$/;"	f
compile	deps/plug/lib/plug/router.ex	/^  defp compile(method, expr, options, contents) do$/;"	f
compile_guards	deps/plug/lib/plug/builder.ex	/^  defp compile_guards(call, guards) do$/;"	f
compile_guards	deps/plug/lib/plug/builder.ex	/^  defp compile_guards(call, true) do$/;"	f
configure_session	deps/plug/lib/plug/conn.ex	/^  def configure_session(%Conn{state: state}, _opts) when not state in @unsent,$/;"	f
configure_session	deps/plug/lib/plug/conn.ex	/^  def configure_session(conn, opts) do$/;"	f
conn	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def conn(req, transport) do$/;"	f
conn	deps/plug/lib/plug/adapters/test/conn.ex	/^  def conn(conn, method, uri, body_or_params) do$/;"	f
conn	deps/plug/lib/plug/test.ex	/^  def conn(method, path, params_or_body \\\\ nil) do$/;"	f
conn_info	deps/plug/lib/plug/adapters/translator.ex	/^  defp conn_info(_min_level, conn) do$/;"	f
connection_type	deps/plug/lib/plug/logger.ex	/^  defp connection_type(%{state: :chunked}), do: "Chunked"$/;"	f
connection_type	deps/plug/lib/plug/logger.ex	/^  defp connection_type(_), do: "Sent"$/;"	f
content_type	deps/maru/lib/maru/helpers/response.ex	/^  defmacro content_type(value) do$/;"	a
content_type	deps/maru/lib/maru/response.ex	/^  def content_type(_) do$/;"	f
content_type	deps/maru/lib/maru/response.ex	/^  def content_type(resp)$/;"	f
content_type	deps/plug/lib/plug/conn/utils.ex	/^  def content_type(binary) do$/;"	f
convert_parsers	deps/plug/lib/plug/parsers.ex	/^  defp convert_parsers(parsers) do$/;"	f
convert_store	deps/plug/lib/plug/session.ex	/^  defp convert_store(store) do$/;"	f
cross_origin_js?	deps/plug/lib/plug/csrf_protection.ex	/^  defp cross_origin_js?(%Plug.Conn{method: "GET"} = conn),$/;"	f
cross_origin_js?	deps/plug/lib/plug/csrf_protection.ex	/^  defp cross_origin_js?(%Plug.Conn{}),$/;"	f
decode	deps/plug/lib/plug/conn/cookies.ex	/^  def decode(cookie) do$/;"	f
decode	deps/plug/lib/plug/conn/query.ex	/^  def decode("", initial) do$/;"	f
decode	deps/plug/lib/plug/conn/query.ex	/^  def decode(query, initial \\\\ %{})$/;"	f
decode	deps/plug/lib/plug/conn/query.ex	/^  def decode(query, initial) do$/;"	f
decode	deps/plug/lib/plug/parsers/json.ex	/^  defp decode({:more, _, conn}, _decoder) do$/;"	f
decode	deps/plug/lib/plug/parsers/json.ex	/^  defp decode({:ok, "", conn}, _decoder) do$/;"	f
decode	deps/plug/lib/plug/parsers/json.ex	/^  defp decode({:ok, body, conn}, decoder) do$/;"	f
decode	deps/plug/lib/plug/session/cookie.ex	/^  defp decode(:error, _serializer) do$/;"	f
decode	deps/plug/lib/plug/session/cookie.ex	/^  defp decode({:ok, binary}, :external_term_format) do$/;"	f
decode	deps/plug/lib/plug/session/cookie.ex	/^  defp decode({:ok, binary}, serializer) do$/;"	f
decode	deps/poison/lib/poison.ex	/^  def decode(iodata, options \\\\ []) do$/;"	f
decode	deps/poison/lib/poison/decoder.ex	/^  def decode(value, _options) do$/;"	f
decode	deps/poison/lib/poison/decoder.ex	/^  def decode(value, options) when is_map(value) or is_list(value) do$/;"	f
decode	deps/poison/lib/poison/decoder.ex	/^  def decode(value, options)$/;"	f
decode!	deps/poison/lib/poison.ex	/^  def decode!(iodata, options \\\\ []) do$/;"	f
decode_key	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_key("", _key),$/;"	f
decode_key	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_key(<< ?=, _ :: binary >>, ""),$/;"	f
decode_key	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_key(<< ?=, t :: binary >>, key),$/;"	f
decode_key	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_key(<< h, _ :: binary >>, _key) when h in [?\\s, ?\\t, ?\\r, ?\\n, ?\\v, ?\\f],$/;"	f
decode_key	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_key(<< h, t :: binary >>, key),$/;"	f
decode_kv	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_kv(""),$/;"	f
decode_kv	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_kv(<< ?$, _ :: binary >>),$/;"	f
decode_kv	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_kv(<< h, t :: binary >>) when h in [?\\s, ?\\t],$/;"	f
decode_kv	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_kv(kv),$/;"	f
decode_pair	deps/plug/lib/plug/conn/query.ex	/^  def decode_pair({key, value}, acc) do$/;"	f
decode_string_pair	deps/plug/lib/plug/conn/query.ex	/^  defp decode_string_pair(binary, acc) do$/;"	f
decode_value	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_value("", _spaces, key, value),$/;"	f
decode_value	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_value(<< ?\\s, t :: binary >>, spaces, key, value),$/;"	f
decode_value	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_value(<< h, _ :: binary >>, _spaces, _key, _value) when h in [?\\t, ?\\r, ?\\n, ?\\v, ?\\f],$/;"	f
decode_value	deps/plug/lib/plug/conn/cookies.ex	/^  defp decode_value(<< h, t :: binary >>, spaces, key, value),$/;"	f
decrypt	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  defp decrypt(encrypted, cipher, secret, iv) do$/;"	f
delete	deps/plug/lib/plug/router.ex	/^  defmacro delete(path, options, contents \\\\ []) do$/;"	a
delete	deps/plug/lib/plug/session/cookie.ex	/^  def delete(_conn, _sid, _opts) do$/;"	f
delete	deps/plug/lib/plug/session/ets.ex	/^  def delete(_conn, sid, table) do$/;"	f
delete	deps/plug/lib/plug/session/store.ex	/^  defcallback delete(Plug.Conn.t, sid, Plug.opts) :: :ok$/;"	c
delete_cookie	deps/plug/lib/plug/session.ex	/^  defp delete_cookie(conn, %{cookie_opts: cookie_opts, key: key}),$/;"	f
delete_csrf_token	deps/plug/lib/plug/csrf_protection.ex	/^  def delete_csrf_token do$/;"	f
delete_req_cookie	deps/plug/lib/plug/test.ex	/^  def delete_req_cookie(%Conn{req_cookies: %Plug.Conn.Unfetched{}} = conn, key)$/;"	f
delete_req_cookie	deps/plug/lib/plug/test.ex	/^  def delete_req_cookie(_conn, key) when is_binary(key) do$/;"	f
delete_req_header	deps/plug/lib/plug/conn.ex	/^  def delete_req_header(%Conn{req_headers: headers} = conn, key) when$/;"	f
delete_req_header	deps/plug/lib/plug/conn.ex	/^  def delete_req_header(%Conn{state: :sent}, _key) do$/;"	f
delete_resp_cookie	deps/plug/lib/plug/conn.ex	/^  def delete_resp_cookie(%Conn{resp_cookies: resp_cookies} = conn, key, opts \\\\ []) when$/;"	f
delete_resp_header	deps/plug/lib/plug/conn.ex	/^  def delete_resp_header(%Conn{resp_headers: headers} = conn, key) when$/;"	f
delete_resp_header	deps/plug/lib/plug/conn.ex	/^  def delete_resp_header(%Conn{state: :sent}, _key) do$/;"	f
delete_session	deps/plug/lib/plug/conn.ex	/^  def delete_session(%Conn{state: state}, _key) when not state in @unsent,$/;"	f
delete_session	deps/plug/lib/plug/conn.ex	/^  def delete_session(conn, key) do$/;"	f
delete_session	deps/plug/lib/plug/session.ex	/^  defp delete_session(sid, conn, %{store: store, store_config: store_config}),$/;"	f
deps	deps/maru/mix.exs	/^  defp deps do$/;"	f
deps	deps/plug/mix.exs	/^  def deps do$/;"	f
deps	deps/poison/mix.exs	/^  defp deps do$/;"	f
deps	mix.exs	/^  defp deps do$/;"	f
derive	deps/plug/lib/plug/session/cookie.ex	/^  defp derive(conn, key, key_opts) do$/;"	f
deriving	deps/poison/lib/poison/encoder.ex	/^  def deriving(module, _struct, options) do$/;"	f
desc	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro desc(desc) do$/;"	a
digest	deps/plug/lib/plug/crypto/message_verifier.ex	/^  defp digest(secret, data) do$/;"	f
dispatch	deps/maru/lib/maru/router/endpoint.ex	/^  def dispatch(ep) do$/;"	f
dispatch	deps/plug/lib/plug/router.ex	/^      defp dispatch(%Plug.Conn{assigns: assigns} = conn, _opts) do$/;"	f
dispatch	lib/leanpoker_elixir/dispatcher.ex	/^  def dispatch(action, game_state) do$/;"	f
dispatch_405	deps/maru/lib/maru/router/endpoint.ex	/^  def dispatch_405(version, path) do$/;"	f
dispatch_for	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp dispatch_for(plug, opts) do$/;"	f
do_check_param	deps/maru/lib/maru/router/endpoint.ex	/^  defp do_check_param([], _attr_name, value), do: value$/;"	f
do_check_param	deps/maru/lib/maru/router/endpoint.ex	/^  defp do_check_param([{validator, option}|t], attr_name, value) do$/;"	f
do_decode	deps/plug/lib/plug/conn/cookies.ex	/^  defp do_decode([], acc),$/;"	f
do_decode	deps/plug/lib/plug/conn/cookies.ex	/^  defp do_decode([h|t], acc) do$/;"	f
do_match	deps/plug/lib/plug/router.ex	/^      defp do_match(unquote(conn), unquote(method), unquote(match), unquote(host)) when unquote(guards) do$/;"	f
do_parse_params	deps/maru/lib/maru/router/path.ex	/^  defp do_parse_params([], [], result), do: result$/;"	f
do_parse_params	deps/maru/lib/maru/router/path.ex	/^  defp do_parse_params([h1|t1], [h2|t2], result) when is_atom(h2) do$/;"	f
do_parse_params	deps/maru/lib/maru/router/path.ex	/^  defp do_parse_params([h|t1], [h|t2], result) do$/;"	f
do_send	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp do_send(%{owner: owner, ref: ref} = state, status, headers, body) do$/;"	f
downcase_char	deps/plug/lib/plug/conn/utils.ex	/^  defp downcase_char(char) when char in @upper, do: char + 32$/;"	f
downcase_char	deps/plug/lib/plug/conn/utils.ex	/^  defp downcase_char(char), do: char$/;"	f
each_frame	deps/plug/lib/plug/debugger.ex	/^  defp each_frame(entry, index, root, editor) do$/;"	f
encode	deps/plug/lib/plug/conn/cookies.ex	/^  def encode(key, opts \\\\ %{}) when is_map(opts) do$/;"	f
encode	deps/plug/lib/plug/conn/query.ex	/^  def encode(dict, encoder \\\\ &to_string\/1) do$/;"	f
encode	deps/plug/lib/plug/session/cookie.ex	/^  defp encode(term, :external_term_format) do$/;"	f
encode	deps/plug/lib/plug/session/cookie.ex	/^  defp encode(term, serializer) do$/;"	f
encode	deps/poison/lib/poison.ex	/^  def encode(value, options \\\\ []) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^        def encode(struct, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode("", _), do: "\\"\\""$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(%{__struct__: _} = struct, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode([], _), do: "[]"$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(atom, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(collection, false, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(collection, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(collection, true, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(dict, false, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(dict, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(dict, true, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(false, _), do: "false"$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(float, _options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(integer, _options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(list, false, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(list, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(list, true, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(map, _) when map_size(map) < 1, do: "{}"$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(map, _, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(map, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(map, true, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(nil, _),   do: "null"$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(string, options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(true, _),  do: "true"$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(value, _options) do$/;"	f
encode	deps/poison/lib/poison/encoder.ex	/^  def encode(value, options)$/;"	f
encode!	deps/poison/lib/poison.ex	/^  def encode!(value, options \\\\ []) do$/;"	f
encode_dict	deps/plug/lib/plug/conn/query.ex	/^  defp encode_dict(dict, parent_field, encoder) do$/;"	f
encode_key	deps/plug/lib/plug/conn/query.ex	/^  defp encode_key(item) do$/;"	f
encode_name	deps/poison/lib/poison/encoder.ex	/^      defp encode_name(value) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(field, %{__struct__: struct} = map, encoder) when is_atom(struct) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(field, nil, _encoder) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(field, value, encoder) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(parent_field, %{} = map, encoder) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(parent_field, list, encoder) when is_list(list) and is_tuple(hd(list)) do$/;"	f
encode_pair	deps/plug/lib/plug/conn/query.ex	/^  defp encode_pair(parent_field, list, encoder) when is_list(list) do$/;"	f
encode_to_iodata	deps/poison/lib/poison.ex	/^  def encode_to_iodata(value, options \\\\ []) do$/;"	f
encode_to_iodata!	deps/poison/lib/poison.ex	/^  def encode_to_iodata!(value, options \\\\ []) do$/;"	f
encode_value	deps/plug/lib/plug/conn/query.ex	/^  defp encode_value(item, encoder) do$/;"	f
encrypt	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  defp encrypt(message, cipher, secret, iv) do$/;"	f
encrypt_and_sign	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  def encrypt_and_sign(message, secret, sign_secret, cipher \\\\ :aes_cbc256)$/;"	f
endpoint	deps/maru/lib/maru/builder.ex	/^      defp endpoint(conn, _), do: conn$/;"	f
endpoint	deps/maru/lib/maru/builder/methods.ex	/^  defp endpoint(ep) do$/;"	f
endpoint	deps/maru/lib/maru/router/endpoint.ex	/^      defp endpoint(%Plug.Conn{$/;"	f
ensure_accepted_mimes	deps/plug/lib/plug/parsers.ex	/^  defp ensure_accepted_mimes(conn, _type, _subtype, ["*\/*"]), do: conn$/;"	f
ensure_accepted_mimes	deps/plug/lib/plug/parsers.ex	/^  defp ensure_accepted_mimes(conn, type, subtype, pass) do$/;"	f
ensure_csrf_token	deps/plug/lib/plug/csrf_protection.ex	/^  defp ensure_csrf_token(conn, csrf_token) do$/;"	f
ensure_same_origin_and_csrf_token!	deps/plug/lib/plug/csrf_protection.ex	/^  defp ensure_same_origin_and_csrf_token!(conn, csrf_token) do$/;"	f
ensure_tmp_dir	deps/plug/lib/plug/upload.ex	/^  defp ensure_tmp_dir(tmps) do$/;"	f
entry	deps/plug/lib/plug/mime.ex	/^    defp entry(unquote(type)), do: unquote(exts)$/;"	f
entry	deps/plug/lib/plug/mime.ex	/^  defp entry(_type), do: nil$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^    defp escape(<<unquote(char)>> <> rest, mode) do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape("", _), do: []$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(<<char :: utf8>> <> rest, :javascript) when char in [0x2028, 0x2029] do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(<<char :: utf8>> <> rest, :unicode) when char > 0xFFFF do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(<<char :: utf8>> <> rest, :unicode) when char in 0xA0..0xFFFF do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(<<char :: utf8>> <> rest, mode) when char in 0x80..0x9F do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(<<char>> <> rest, mode) when char < 0x1F or char == 0x7F do$/;"	f
escape	deps/poison/lib/poison/encoder.ex	/^  defp escape(string, mode) do$/;"	f
escape_char	deps/plug/lib/plug/html.ex	/^    defp escape_char(unquote(match)), do: unquote(insert)$/;"	f
escape_char	deps/plug/lib/plug/html.ex	/^  defp escape_char(char), do: char$/;"	f
etag_for_path	deps/plug/lib/plug/static.ex	/^  defp etag_for_path(file_info) do$/;"	f
exception	deps/poison/lib/poison/parser.ex	/^  def exception(opts) do$/;"	f
extensions	deps/plug/lib/plug/mime.ex	/^  def extensions(type) do$/;"	f
extract_path	deps/plug/lib/plug/router.ex	/^  defp extract_path(path), do: path$/;"	f
extract_path	deps/plug/lib/plug/router.ex	/^  defp extract_path({:_, _, var}) when is_atom(var), do: "\/*_path"$/;"	f
extract_path_and_guards	deps/plug/lib/plug/router.ex	/^  defp extract_path_and_guards(path), do: {extract_path(path), true}$/;"	f
extract_path_and_guards	deps/plug/lib/plug/router.ex	/^  defp extract_path_and_guards({:when, _, [path, guards]}), do: {extract_path(path), guards}$/;"	f
extract_private_merger	deps/plug/lib/plug/router.ex	/^  defp extract_private_merger(options) when is_list(options) do$/;"	f
fail	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp fail(message) do$/;"	f
fetch_cookies	deps/plug/lib/plug/conn.ex	/^  def fetch_cookies(%Conn{req_cookies: %Unfetched{},$/;"	f
fetch_cookies	deps/plug/lib/plug/conn.ex	/^  def fetch_cookies(%Conn{} = conn, _opts) do$/;"	f
fetch_cookies	deps/plug/lib/plug/conn.ex	/^  def fetch_cookies(conn, opts \\\\ [])$/;"	f
fetch_query_params	deps/plug/lib/plug/conn.ex	/^  def fetch_query_params(%Conn{query_params: %Unfetched{}, params: params,$/;"	f
fetch_query_params	deps/plug/lib/plug/conn.ex	/^  def fetch_query_params(%Conn{} = conn, _opts) do$/;"	f
fetch_query_params	deps/plug/lib/plug/conn.ex	/^  def fetch_query_params(conn, opts \\\\ [])$/;"	f
fetch_session	deps/plug/lib/plug/conn.ex	/^  def fetch_session(%Conn{private: private} = conn, _opts) do$/;"	f
fetch_session	deps/plug/lib/plug/conn.ex	/^  def fetch_session(conn, opts \\\\ [])$/;"	f
fetch_session	deps/plug/lib/plug/session.ex	/^  defp fetch_session(config) do$/;"	f
file_encoding	deps/plug/lib/plug/static.ex	/^  defp file_encoding(conn, path, gzip) do$/;"	f
filter_except	deps/maru/lib/maru/plugs/extend.ex	/^  def filter_except(_, nil), do: true$/;"	f
filter_except	deps/maru/lib/maru/plugs/extend.ex	/^  def filter_except(endpoint, except) do$/;"	f
filter_only	deps/maru/lib/maru/plugs/extend.ex	/^  def filter_only(_, nil), do: true$/;"	f
filter_only	deps/maru/lib/maru/plugs/extend.ex	/^  def filter_only(endpoint, only) do$/;"	f
filter_origin	deps/maru/lib/maru/plugs/extend.ex	/^  def filter_origin(endpoint, origin_endpoints) do$/;"	f
find_tmp_dir	deps/plug/lib/plug/upload.ex	/^  defp find_tmp_dir(pid, tmps, ets) do$/;"	f
format_method	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_method(method) do$/;"	f
format_method	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_method({:_, [], nil}), do: ":match" |> format_method$/;"	f
format_path	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_path([]), do: "\/"$/;"	f
format_path	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_path(p) do$/;"	f
format_version	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_version(nil), do: "nil" |> format_version$/;"	f
format_version	deps/maru/lib/mix/tasks/routers.ex	/^  defp format_version(version) do$/;"	f
formatted_diff	deps/plug/lib/plug/logger.ex	/^  defp formatted_diff(diff) when diff > 1000, do: [diff |> div(1000) |> Integer.to_string, "ms"]$/;"	f
formatted_diff	deps/plug/lib/plug/logger.ex	/^  defp formatted_diff(diff), do: [diff |> Integer.to_string, "µs"]$/;"	f
forward	deps/plug/lib/plug/router.ex	/^  defmacro forward(path, options) when is_binary(path) do$/;"	a
forward	deps/plug/lib/plug/router/utils.ex	/^  def forward(%Plug.Conn{path_info: path, script_name: script} = conn, new_path, target, opts) do$/;"	f
frames	deps/plug/lib/plug/debugger.ex	/^  defp frames(stacktrace, opts) do$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from("false"), do: false$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from("true"), do: true$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(%Plug.Upload{}=f), do: f$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(any), do: any$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(list) when is_list(list), do: list$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(map) when is_map(map), do: map$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(nil), do: false$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s) do$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s) when is_atom(s), do: s$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s) when is_boolean(s), do: s$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s) when is_float(s), do: s$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s) when is_integer(s), do: :erlang.float(s)$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s), do: s |> to_char_list$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s), do: s |> to_string |> Elixir.String.to_existing_atom$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s), do: s |> to_string |> Elixir.String.to_integer$/;"	f
from	deps/maru/lib/maru/param_type.ex	/^    def from(s), do: s |> to_string$/;"	f
generate	deps/maru/lib/maru/builder/routers.ex	/^  def generate(module) do$/;"	f
generate	deps/plug/lib/plug/crypto/key_generator.ex	/^  def generate(secret, salt, opts \\\\ []) do$/;"	f
generate	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp generate(_fun, _salt, _iterations, max_length, _block_index, acc, length)$/;"	f
generate	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp generate(fun, salt, iterations, max_length, block_index, acc, length) do$/;"	f
generate_detail	deps/maru/lib/maru/builder/routers.ex	/^  defp generate_detail(module, mount_path, mount_version, all_modules) do$/;"	f
generate_endpoint	deps/maru/lib/mix/tasks/routers.ex	/^  defp generate_endpoint(ep) do$/;"	f
generate_module	deps/maru/lib/maru/builder/routers.ex	/^  defp generate_module(module, options, generated) do$/;"	f
generate_request_id	deps/plug/lib/plug/request_id.ex	/^  defp generate_request_id do$/;"	f
generate_token	deps/plug/lib/plug/csrf_protection.ex	/^  defp generate_token do$/;"	f
get	deps/plug/lib/plug/conn/unfetched.ex	/^  def get(%{aspect: aspect}, key, _value) do$/;"	f
get	deps/plug/lib/plug/router.ex	/^  defmacro get(path, options, contents \\\\ []) do$/;"	a
get	deps/plug/lib/plug/session/cookie.ex	/^  def get(conn, cookie, opts) do$/;"	f
get	deps/plug/lib/plug/session/ets.ex	/^  def get(_conn, sid, table) do$/;"	f
get	deps/plug/lib/plug/session/store.ex	/^  defcallback get(Plug.Conn.t, cookie, Plug.opts) :: {sid, session}$/;"	c
get_and_update	deps/plug/lib/plug/conn/unfetched.ex	/^  def get_and_update(%{aspect: aspect}, key, _fun) do$/;"	f
get_app	deps/plug/lib/plug/debugger.ex	/^  defp get_app(module) do$/;"	f
get_context	deps/plug/lib/plug/debugger.ex	/^  defp get_context(_app1, _app2),             do: :all$/;"	f
get_context	deps/plug/lib/plug/debugger.ex	/^  defp get_context(app, app) when app != nil, do: :app$/;"	f
get_csrf_from_session	deps/plug/lib/plug/csrf_protection.ex	/^  defp get_csrf_from_session(conn) do$/;"	f
get_csrf_token	deps/plug/lib/plug/csrf_protection.ex	/^  def get_csrf_token do$/;"	f
get_editor	deps/plug/lib/plug/debugger.ex	/^  defp get_editor(file, line, editor) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({_module, :__FILE__, 1, location}) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({_module, :__MODULE__, 1, location}) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({fun, arity, location}) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({module, :__MODULE__, 0, location}) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({module, fun, args, location}) when is_list(args) do$/;"	f
get_entry	deps/plug/lib/plug/debugger.ex	/^  defp get_entry({module, fun, arity, location}) do$/;"	f
get_extend_opts	deps/maru/lib/maru/builder/routers.ex	/^  defp get_extend_opts(nil),         do: nil$/;"	f
get_extend_opts	deps/maru/lib/maru/builder/routers.ex	/^  defp get_extend_opts({_, opts, _}), do: opts$/;"	f
get_header	deps/plug/lib/plug/parsers/multipart.ex	/^  defp get_header(headers, key) do$/;"	f
get_present_value	deps/maru/lib/maru/helpers/response.ex	/^  defp get_present_value(payload, opts) do$/;"	f
get_req_header	deps/plug/lib/plug/conn.ex	/^  def get_req_header(%Conn{req_headers: headers}, key) when is_binary(key) do$/;"	f
get_request_id	deps/plug/lib/plug/request_id.ex	/^  defp get_request_id(conn, header) do$/;"	f
get_resp_header	deps/plug/lib/plug/conn.ex	/^  def get_resp_header(%Conn{resp_headers: headers}, key) when is_binary(key) do$/;"	f
get_session	deps/plug/lib/plug/conn.ex	/^  def get_session(conn, key) do$/;"	f
get_session	deps/plug/lib/plug/conn.ex	/^  defp get_session(%Conn{private: private}) do$/;"	f
get_snippet	deps/plug/lib/plug/debugger.ex	/^  defp get_snippet(file, line) do$/;"	f
get_source	deps/plug/lib/plug/debugger.ex	/^  defp get_source(module, file) do$/;"	f
group	deps/maru/lib/maru/builder/params.ex	/^  defmacro group(group_name, options \\\\ [], [do: block]) do$/;"	a
gzip?	deps/plug/lib/plug/static.ex	/^  defp gzip?(conn) do$/;"	f
h	deps/plug/lib/plug/debugger.ex	/^  defp h(string) do$/;"	f
halt	deps/plug/lib/plug/conn.ex	/^  def halt(%Conn{} = conn) do$/;"	f
handle_call	deps/plug/lib/plug/upload.ex	/^  def handle_call(msg, from, state) do$/;"	f
handle_call	deps/plug/lib/plug/upload.ex	/^  def handle_call({:random, prefix}, {pid, _ref}, {tmps, ets} = state) do$/;"	f
handle_disposition	deps/plug/lib/plug/parsers/multipart.ex	/^  defp handle_disposition(disposition, headers) do$/;"	f
handle_disposition_params	deps/plug/lib/plug/parsers/multipart.ex	/^  defp handle_disposition_params(name, params, headers) do$/;"	f
handle_errors	deps/plug/lib/plug/error_handler.ex	/^        defp handle_errors(conn, %{kind: _kind, reason: _reason, stack: _stack}) do$/;"	f
handle_errors	deps/plug/lib/plug/error_handler.ex	/^      defp handle_errors(conn, assigns) do$/;"	f
handle_errors	deps/plug/lib/plug/router.ex	/^        defp handle_errors(conn, %{kind: _kind, reason: _reason, stack: _stack}) do$/;"	f
handle_headers	deps/plug/lib/plug/parsers/multipart.ex	/^  defp handle_headers(headers) do$/;"	f
handle_info	deps/plug/lib/plug/upload.ex	/^  def handle_info(msg, state) do$/;"	f
handle_info	deps/plug/lib/plug/upload.ex	/^  def handle_info({:DOWN, _ref, :process, pid, _reason}, {_, ets} = state) do$/;"	f
handle_segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp handle_segment_match({:glob, _identifier, _expr}, t, _context, _vars, _acc) when t != [] do$/;"	f
handle_segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp handle_segment_match({:glob, identifier, expr}, _t, context, vars, [hs|ts]) do$/;"	f
handle_segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp handle_segment_match({:glob, identifier, expr}, _t, context, vars, _) do$/;"	f
handle_segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp handle_segment_match({:identifier, identifier, expr}, t, context, vars, acc) do$/;"	f
handle_segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp handle_segment_match({:literal, literal}, t, context, vars, acc) do$/;"	f
header	deps/maru/lib/maru/helpers/response.ex	/^  defmacro header(key, nil) do$/;"	a
header	deps/maru/lib/maru/helpers/response.ex	/^  defmacro header(key, value) do$/;"	a
hello	deps/plug/lib/plug/builder.ex	/^        def hello(conn, opts) do$/;"	f
helpers	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro helpers([do: block]) do$/;"	a
helpers	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro helpers({_, _, mod}) do$/;"	a
hsts_header	deps/plug/lib/plug/ssl.ex	/^  defp hsts_header(opts) do$/;"	f
html_escape	deps/plug/lib/plug/html.ex	/^  def html_escape(data) when is_binary(data) do$/;"	f
http	deps/plug/lib/plug/adapters/cowboy.ex	/^  def http(plug, opts, cowboy_options \\\\ []) do$/;"	f
https	deps/plug/lib/plug/adapters/cowboy.ex	/^  def https(plug, opts, cowboy_options \\\\ []) do$/;"	f
i	deps/plug/lib/plug/upload.ex	/^  defp i(integer), do: Integer.to_string(integer)$/;"	f
indent	deps/poison/lib/poison/encoder.ex	/^      defp indent(options) do$/;"	f
info	deps/plug/lib/plug/debugger.ex	/^  defp info(:error, error) do$/;"	f
info	deps/plug/lib/plug/debugger.ex	/^  defp info(:exit, reason) do$/;"	f
info	deps/plug/lib/plug/debugger.ex	/^  defp info(:throw, thrown) do$/;"	f
init	deps/maru/lib/maru/builder.ex	/^      def init(_), do: []$/;"	f
init	deps/maru/lib/maru/middleware.ex	/^      def init(opts), do: opts$/;"	f
init	deps/maru/lib/maru/plugs/extend.ex	/^  def init(opts) do$/;"	f
init	deps/maru/lib/maru/plugs/notfound.ex	/^  def init(opts), do: opts$/;"	f
init	deps/maru/lib/maru/plugs/prepare.ex	/^  def init(_), do: []$/;"	f
init	deps/maru/lib/maru/plugs/router.ex	/^  def init(opts) do$/;"	f
init	deps/maru/lib/maru/plugs/version.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug.ex	/^        def init(opts) do$/;"	f
init	deps/plug/lib/plug.ex	/^  defcallback init(opts) :: opts$/;"	c
init	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  def init({transport, :http}, req, {plug, opts}) when transport in [:tcp, :ssl] do$/;"	f
init	deps/plug/lib/plug/builder.ex	/^        def init(opts) do$/;"	f
init	deps/plug/lib/plug/builder.ex	/^      def init(opts) do$/;"	f
init	deps/plug/lib/plug/csrf_protection.ex	/^  def init(opts), do: opts$/;"	f
init	deps/plug/lib/plug/head.ex	/^  def init([]), do: []$/;"	f
init	deps/plug/lib/plug/logger.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/method_override.ex	/^  def init([]), do: []$/;"	f
init	deps/plug/lib/plug/parsers.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/request_id.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/session.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/session/cookie.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/session/ets.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/session/store.ex	/^  defcallback init(Plug.opts) :: Plug.opts$/;"	c
init	deps/plug/lib/plug/ssl.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/static.ex	/^  def init(opts) do$/;"	f
init	deps/plug/lib/plug/supervisor.ex	/^  def init(:ok) do$/;"	f
init	deps/plug/lib/plug/upload.ex	/^  def init(:ok) do$/;"	f
init_fun_plug	deps/plug/lib/plug/builder.ex	/^  defp init_fun_plug(plug, opts, guards) do$/;"	f
init_module_plug	deps/plug/lib/plug/builder.ex	/^  defp init_module_plug(plug, opts, guards) do$/;"	f
init_plug	deps/plug/lib/plug/builder.ex	/^  defp init_plug({plug, opts, guards}) do$/;"	f
inspect	deps/plug/lib/plug/conn.ex	/^  def inspect(conn, opts) do$/;"	f
into	deps/plug/lib/plug/conn.ex	/^  def into(conn) do$/;"	f
invalid_path?	deps/plug/lib/plug/static.ex	/^  defp invalid_path?([]), do: false$/;"	f
invalid_path?	deps/plug/lib/plug/static.ex	/^  defp invalid_path?([h|_]) when h in [".", "..", ""], do: true$/;"	f
invalid_path?	deps/plug/lib/plug/static.ex	/^  defp invalid_path?([h|t]), do: String.contains?(h, ["\/", "\\\\", ":"]) or invalid_path?(t)$/;"	f
iterate	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp iterate(_fun, 0, _prev, acc), do: acc$/;"	f
iterate	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp iterate(fun, iteration, prev, acc) do$/;"	f
join_guards	deps/plug/lib/plug/router.ex	/^  defp join_guards(fst, snd),  do: (quote do: unquote(fst) and unquote(snd))$/;"	f
join_guards	deps/plug/lib/plug/router.ex	/^  defp join_guards(fst, true), do: fst$/;"	f
js_content_type?	deps/plug/lib/plug/csrf_protection.ex	/^  defp js_content_type?(conn) do$/;"	f
json_header_plug	deps/plug/lib/plug.ex	/^      def json_header_plug(conn, opts) do$/;"	f
list	deps/plug/lib/plug/conn/utils.ex	/^  def list(binary) do$/;"	f
log_halt	deps/plug/lib/plug/builder.ex	/^  defp log_halt(plug_type, plug, env, builder_opts) do$/;"	f
lstrip	deps/maru/lib/maru/plugs/extend.ex	/^  defp lstrip([], []),                         do: true$/;"	f
lstrip	deps/maru/lib/maru/plugs/extend.ex	/^  defp lstrip([_|t1], [h|t2]) when is_atom(h), do: lstrip(t1, t2)$/;"	f
lstrip	deps/maru/lib/maru/plugs/extend.ex	/^  defp lstrip([h|t1], [h|t2]),                 do: lstrip(t1, t2)$/;"	f
lstrip	deps/maru/lib/maru/plugs/extend.ex	/^  defp lstrip(_, _),                           do: false$/;"	f
lstrip	deps/maru/lib/maru/plugs/extend.ex	/^  defp lstrip(_rest, ["*"]),                   do: true$/;"	f
lstrip	deps/maru/lib/maru/router/endpoint.ex	/^  defp lstrip([h|t1], [h|t2]), do: lstrip(t1, t2)$/;"	f
lstrip	deps/maru/lib/maru/router/endpoint.ex	/^  defp lstrip(_, _),           do: nil$/;"	f
lstrip	deps/maru/lib/maru/router/endpoint.ex	/^  defp lstrip(rest, []),       do: {:ok, rest}$/;"	f
lstrip	deps/maru/lib/maru/router/path.ex	/^  def lstrip([_|t1], [h|t2]) when is_atom(h), do: lstrip(t1, t2)$/;"	f
lstrip	deps/maru/lib/maru/router/path.ex	/^  def lstrip([h|t1], [h|t2]),                 do: lstrip(t1, t2)$/;"	f
lstrip	deps/maru/lib/maru/router/path.ex	/^  def lstrip(_, _),                           do: nil$/;"	f
lstrip	deps/maru/lib/maru/router/path.ex	/^  def lstrip(rest, []),                       do: {:ok, rest}$/;"	f
mac_fun	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp mac_fun(digest, secret) do$/;"	f
make_rescue_block	deps/maru/lib/maru/builder/exceptions.ex	/^  def make_rescue_block({:all, block}) do$/;"	f
make_rescue_block	deps/maru/lib/maru/builder/exceptions.ex	/^  def make_rescue_block({:all, error_var, block}) do$/;"	f
make_rescue_block	deps/maru/lib/maru/builder/exceptions.ex	/^  def make_rescue_block({error, block}) do$/;"	f
make_rescue_block	deps/maru/lib/maru/builder/exceptions.ex	/^  def make_rescue_block({error, error_var, block}) do$/;"	f
make_response	deps/maru/lib/maru/test.ex	/^      defp make_response(conn, version \\\\ nil) do$/;"	f
mask	deps/plug/lib/plug/crypto.ex	/^  def mask(left, right) do$/;"	f
mask	deps/plug/lib/plug/crypto.ex	/^  defp mask(<<>>, <<>>, acc) do$/;"	f
mask	deps/plug/lib/plug/crypto.ex	/^  defp mask(<<x, left::binary>>, <<y, right::binary>>, acc) do$/;"	f
mask	deps/plug/lib/plug/csrf_protection.ex	/^  defp mask(token) do$/;"	f
masked_compare	deps/plug/lib/plug/crypto.ex	/^  def masked_compare(left, right, mask) do$/;"	f
masked_compare	deps/plug/lib/plug/crypto.ex	/^  defp masked_compare(<<>>, <<>>, <<>>, acc) do$/;"	f
masked_compare	deps/plug/lib/plug/crypto.ex	/^  defp masked_compare(<<x, left::binary>>, <<y, right::binary>>, <<z, mask::binary>>, acc) do$/;"	f
match	deps/maru/lib/maru/builder/methods.ex	/^  defmacro match(path \\\\ "", [do: block]) do$/;"	a
match	deps/plug/lib/plug/router.ex	/^      defp match("GET", ["foo", "bar"], conn) do$/;"	f
match	deps/plug/lib/plug/router.ex	/^      defp match(conn, _opts) do$/;"	f
match	deps/plug/lib/plug/router.ex	/^  defmacro match(path, options, contents \\\\ []) do$/;"	a
maybe_add_vary	deps/plug/lib/plug/static.ex	/^  defp maybe_add_vary(conn, false) do$/;"	f
maybe_add_vary	deps/plug/lib/plug/static.ex	/^  defp maybe_add_vary(conn, true) do$/;"	f
maybe_fetch_query_params	deps/plug/lib/plug/debugger.ex	/^  defp maybe_fetch_query_params(conn) do$/;"	f
maybe_fetch_session	deps/plug/lib/plug/debugger.ex	/^  defp maybe_fetch_session(conn) do$/;"	f
maybe_flush	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp maybe_flush() do$/;"	f
maybe_secure_cookie	deps/plug/lib/plug/conn.ex	/^  defp maybe_secure_cookie(cookie, :https), do: Map.put_new(cookie, :secure, true)$/;"	f
maybe_secure_cookie	deps/plug/lib/plug/conn.ex	/^  defp maybe_secure_cookie(cookie, _),      do: cookie$/;"	f
maybe_send	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  defp maybe_send(%Plug.Conn{state: :set} = conn, _plug), do: Plug.Conn.send_resp(conn)$/;"	f
maybe_send	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  defp maybe_send(%Plug.Conn{state: :unset}, _plug),      do: raise Plug.Conn.NotSentError$/;"	f
maybe_send	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  defp maybe_send(%Plug.Conn{} = conn, _plug),            do: conn$/;"	f
maybe_send	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  defp maybe_send(other, plug) do$/;"	f
media_type	deps/plug/lib/plug/conn/utils.ex	/^  def media_type(binary) do$/;"	f
merge_headers	deps/plug/lib/plug/conn.ex	/^  defp merge_headers(headers, cookies) do$/;"	f
merge_resp_headers	deps/plug/lib/plug/conn.ex	/^  def merge_resp_headers(%Conn{resp_headers: current} = conn, headers) do$/;"	f
merge_resp_headers	deps/plug/lib/plug/conn.ex	/^  def merge_resp_headers(%Conn{state: :sent}, _headers) do$/;"	f
merge_resp_headers	deps/plug/lib/plug/conn.ex	/^  def merge_resp_headers(conn, headers) when headers == %{} do$/;"	f
message	deps/maru/lib/maru/exceptions.ex	/^    def message(_e) do$/;"	f
message	deps/maru/lib/maru/exceptions.ex	/^    def message(e) do$/;"	f
message	deps/plug/lib/plug/conn/wrapper_error.ex	/^  def message(%{kind: kind, reason: reason, stack: stack}) do$/;"	f
message	deps/plug/lib/plug/parsers.ex	/^    def message(exception) do$/;"	f
message	deps/poison/lib/poison/encoder.ex	/^  def message(%{message: message}) do$/;"	f
message	deps/poison/lib/poison/encoder.ex	/^  def message(%{value: value, message: nil}) do$/;"	f
method	deps/plug/lib/plug/debugger.ex	/^  defp method(%Plug.Conn{method: method}), do:$/;"	f
method_match?	deps/maru/lib/maru/plugs/extend.ex	/^  defp method_match?(_m, :match) do$/;"	f
method_match?	deps/maru/lib/maru/plugs/extend.ex	/^  defp method_match?(m1, m2) do$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(1),  do: "Jan"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(10), do: "Oct"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(11), do: "Nov"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(12), do: "Dec"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(2),  do: "Feb"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(3),  do: "Mar"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(4),  do: "Apr"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(5),  do: "May"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(6),  do: "Jun"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(7),  do: "Jul"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(8),  do: "Aug"$/;"	f
month_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp month_name(9),  do: "Sep"$/;"	f
mount	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro mount({_, _, mod}) do$/;"	a
mt_first	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_first(<<?\/, t :: binary>>, acc) when acc != "",$/;"	f
mt_first	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_first(<<h, t :: binary>>, acc) when h in @lower or h in @alpha or h == ?-,$/;"	f
mt_first	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_first(<<h, t :: binary>>, acc) when h in @upper,$/;"	f
mt_first	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_first(_, _acc),$/;"	f
mt_params	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_params(t, first, second) do$/;"	f
mt_second	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_second(<<h, t :: binary>>, acc, first) when h in @lower or h in @alpha or h in @other,$/;"	f
mt_second	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_second(<<h, t :: binary>>, acc, first) when h in @upper,$/;"	f
mt_second	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_second(t, acc, first),$/;"	f
mt_wildcard	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_wildcard(<<?*, t :: binary>>, first),$/;"	f
mt_wildcard	deps/plug/lib/plug/conn/utils.ex	/^  defp mt_wildcard(t, first),$/;"	f
normalize_cowboy_options	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp normalize_cowboy_options(cowboy_options, :http) do$/;"	f
normalize_cowboy_options	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp normalize_cowboy_options(cowboy_options, :https) do$/;"	f
normalize_method	deps/plug/lib/plug/router/utils.ex	/^  def normalize_method(method) do$/;"	f
normalize_ssl_file	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp normalize_ssl_file(key, cowboy_options) do$/;"	f
not_found	deps/plug/lib/plug/static.ex	/^        def not_found(conn, _) do$/;"	f
now	deps/plug/lib/plug/session/ets.ex	/^  defp now() do$/;"	f
number_complete	deps/poison/lib/poison/parser.ex	/^  defp number_complete(iolist, false) do$/;"	f
number_complete	deps/poison/lib/poison/parser.ex	/^  defp number_complete(iolist, true) do$/;"	f
number_digits	deps/poison/lib/poison/parser.ex	/^  defp number_digits(<<char>> <> rest = string) when char in '0123456789' do$/;"	f
number_digits	deps/poison/lib/poison/parser.ex	/^  defp number_digits(other), do: syntax_error(other)$/;"	f
number_digits_count	deps/poison/lib/poison/parser.ex	/^  defp number_digits_count(<<char>> <> rest, acc) when char in '0123456789' do$/;"	f
number_digits_count	deps/poison/lib/poison/parser.ex	/^  defp number_digits_count(_, acc), do: acc$/;"	f
number_exp	deps/poison/lib/poison/parser.ex	/^  defp number_exp(<<e>> <> rest, frac, acc) when e in 'eE' do$/;"	f
number_exp	deps/poison/lib/poison/parser.ex	/^  defp number_exp(string, frac, acc) do$/;"	f
number_exp_continue	deps/poison/lib/poison/parser.ex	/^  defp number_exp_continue(rest, acc) do$/;"	f
number_frac	deps/poison/lib/poison/parser.ex	/^  defp number_frac("." <> rest, acc) do$/;"	f
number_frac	deps/poison/lib/poison/parser.ex	/^  defp number_frac(string, acc) do$/;"	f
number_int	deps/poison/lib/poison/parser.ex	/^  defp number_int(<<char, _ :: binary>> = string, acc) when char in '123456789' do$/;"	f
number_int	deps/poison/lib/poison/parser.ex	/^  defp number_int(other, _), do: syntax_error(other)$/;"	f
number_start	deps/poison/lib/poison/parser.ex	/^  defp number_start("-" <> rest) do$/;"	f
number_start	deps/poison/lib/poison/parser.ex	/^  defp number_start("0" <> rest) do$/;"	f
number_start	deps/poison/lib/poison/parser.ex	/^  defp number_start(string) do$/;"	f
object_name	deps/poison/lib/poison/parser.ex	/^  defp object_name(name, :atoms!), do: String.to_existing_atom(name)$/;"	f
object_name	deps/poison/lib/poison/parser.ex	/^  defp object_name(name, :atoms),  do: String.to_atom(name)$/;"	f
object_name	deps/poison/lib/poison/parser.ex	/^  defp object_name(name, _keys),   do: name$/;"	f
object_pairs	deps/poison/lib/poison/parser.ex	/^  defp object_pairs("\\"" <> rest, keys, acc) do$/;"	f
object_pairs	deps/poison/lib/poison/parser.ex	/^  defp object_pairs("}" <> rest, _, []) do$/;"	f
object_pairs	deps/poison/lib/poison/parser.ex	/^  defp object_pairs(other, _, _), do: syntax_error(other)$/;"	f
offset	deps/poison/lib/poison/encoder.ex	/^      defp offset(options) do$/;"	f
offset	deps/poison/lib/poison/encoder.ex	/^      defp offset(options, value) do$/;"	f
open_random_file	deps/plug/lib/plug/upload.ex	/^  defp open_random_file(_prefix, tmp, attempts, _pid, _ets, _paths) do$/;"	f
open_random_file	deps/plug/lib/plug/upload.ex	/^  defp open_random_file(prefix, tmp, attempts, pid, ets, paths) when attempts < @max_attempts do$/;"	f
optional	deps/maru/lib/maru/builder/params.ex	/^  defmacro optional(attr_name) do$/;"	a
optional	deps/maru/lib/maru/builder/params.ex	/^  defmacro optional(attr_name, [do: block]) do$/;"	a
optional	deps/maru/lib/maru/builder/params.ex	/^  defmacro optional(attr_name, options) do$/;"	a
optional	deps/maru/lib/maru/builder/params.ex	/^  defmacro optional(attr_name, options, [do: block]) do$/;"	a
options	deps/plug/lib/plug/router.ex	/^  defmacro options(path, options, contents \\\\ []) do$/;"	a
otp_app	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp otp_app(cowboy_options) do$/;"	f
override_method	deps/plug/lib/plug/method_override.ex	/^  defp override_method(conn, %Plug.Conn.Unfetched{}) do$/;"	f
override_method	deps/plug/lib/plug/method_override.ex	/^  defp override_method(conn, body_params) do$/;"	f
package	deps/maru/mix.exs	/^  defp package do$/;"	f
package	deps/plug/mix.exs	/^  defp package do$/;"	f
package	deps/poison/mix.exs	/^  defp package do$/;"	f
pad	deps/plug/lib/plug/conn/cookies.ex	/^  defp pad(number) when number in 0..9, do: <<?0, ?0 + number>>$/;"	f
pad	deps/plug/lib/plug/conn/cookies.ex	/^  defp pad(number), do: Integer.to_string(number)$/;"	f
pad_message	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  defp pad_message(msg) do$/;"	f
param	deps/maru/lib/maru/builder/params.ex	/^  defp param(attr_name, options, [required: required, nested: nested]) do$/;"	f
params	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro params(block) do$/;"	a
params	deps/maru/lib/maru/helpers/params.ex	/^  defmacro params(name, [do: block]) do$/;"	a
params	deps/plug/lib/plug/conn/utils.ex	/^  def params(t) do$/;"	f
params	deps/plug/lib/plug/conn/utils.ex	/^  defp params(param, acc) do$/;"	f
params_key	deps/plug/lib/plug/conn/utils.ex	/^  defp params_key(<<>>, _acc),$/;"	f
params_key	deps/plug/lib/plug/conn/utils.ex	/^  defp params_key(<<?=, t :: binary>>, acc) when acc != "",$/;"	f
params_key	deps/plug/lib/plug/conn/utils.ex	/^  defp params_key(<<h, _ :: binary>>, _acc) when h in @specials or h in @space or h < 32 or h === 127,$/;"	f
params_key	deps/plug/lib/plug/conn/utils.ex	/^  defp params_key(<<h, t :: binary>>, acc),$/;"	f
params_value	deps/plug/lib/plug/conn/utils.ex	/^  defp params_value(token, key) do$/;"	f
parse	deps/plug/lib/plug/parsers.ex	/^  defcallback parse(Conn.t, type :: binary, subtype :: binary,$/;"	c
parse	deps/plug/lib/plug/parsers/json.ex	/^  def parse(conn, "application", subtype, _headers, opts) do$/;"	f
parse	deps/plug/lib/plug/parsers/json.ex	/^  def parse(conn, _type, _subtype, _headers, _opts) do$/;"	f
parse	deps/plug/lib/plug/parsers/multipart.ex	/^  def parse(conn, "multipart", subtype, _headers, opts) when subtype in ["form-data", "mixed"] do$/;"	f
parse	deps/plug/lib/plug/parsers/multipart.ex	/^  def parse(conn, _type, _subtype, _headers, _opts) do$/;"	f
parse	deps/plug/lib/plug/parsers/urlencoded.ex	/^  def parse(conn, "application", "x-www-form-urlencoded", _headers, opts) do$/;"	f
parse	deps/plug/lib/plug/parsers/urlencoded.ex	/^  def parse(conn, _type, _subtype, _headers, _opts) do$/;"	f
parse	deps/poison/lib/poison/parser.ex	/^  def parse(iodata, options \\\\ []) do$/;"	f
parse!	deps/poison/lib/poison/parser.ex	/^  def parse!(iodata, options \\\\ []) do$/;"	f
parse_multipart	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart({:done, req}, limit, _opts, acc, _callback) do$/;"	f
parse_multipart	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart({:ok, _headers, req}, limit, _opts, acc, _callback) do$/;"	f
parse_multipart	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart({:ok, headers, req}, limit, opts, acc, callback) when limit >= 0 do$/;"	f
parse_multipart_body	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_body({:more, _tail, req}, limit, _opts, body) do$/;"	f
parse_multipart_body	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_body({:more, tail, req}, limit, opts, body) when limit >= 0 do$/;"	f
parse_multipart_body	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_body({:ok, _tail, req}, limit, _opts, body) do$/;"	f
parse_multipart_body	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_body({:ok, tail, req}, limit, _opts, body) when limit >= byte_size(tail) do$/;"	f
parse_multipart_file	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_file({:more, _tail, req}, limit, _opts, _file) do$/;"	f
parse_multipart_file	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_file({:more, tail, req}, limit, opts, file) when limit >= 0 do$/;"	f
parse_multipart_file	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_file({:ok, _tail, req}, limit, _opts, _file) do$/;"	f
parse_multipart_file	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp parse_multipart_file({:ok, tail, req}, limit, _opts, file) when limit >= byte_size(tail) do$/;"	f
parse_params	deps/maru/lib/maru/router/path.ex	/^  def parse_params(conn_path_info, route_path) do$/;"	f
parse_req_multipart	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def parse_req_multipart(req, opts, callback) do$/;"	f
parse_req_multipart	deps/plug/lib/plug/adapters/test/conn.ex	/^  def parse_req_multipart(%{params: multipart} = state, _limit, _callback) do$/;"	f
parse_req_multipart	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback parse_req_multipart(payload, options :: Keyword.t, fun) ::$/;"	c
patch	deps/plug/lib/plug/router.ex	/^  defmacro patch(path, options, contents \\\\ []) do$/;"	a
path	deps/plug/lib/plug/mime.ex	/^  def path(path) do$/;"	f
path	deps/plug/lib/plug/static.ex	/^  defp path(from, segments),$/;"	f
path	deps/plug/lib/plug/static.ex	/^  defp path({app, from}, segments) when is_atom(app) and is_binary(from),$/;"	f
path	deps/plug/lib/plug/upload.ex	/^  defp path(prefix, tmp) do$/;"	f
path_match?	deps/maru/lib/maru/plugs/extend.ex	/^  defp path_match?(p1, p2) do$/;"	f
path_to_iodata	deps/plug/lib/plug/adapters/translator.ex	/^  defp path_to_iodata(path, ""), do: path$/;"	f
path_to_iodata	deps/plug/lib/plug/adapters/translator.ex	/^  defp path_to_iodata(path, qs), do: [path, ??, qs]$/;"	f
peer	deps/plug/lib/plug/debugger.ex	/^  defp peer(%Plug.Conn{peer: {host, port}}), do:$/;"	f
plug	deps/plug/lib/plug/builder.ex	/^  defmacro plug(plug, opts \\\\ []) do$/;"	a
plug_builder_call	deps/plug/lib/plug/builder.ex	/^      defp plug_builder_call(unquote(conn), _), do: unquote(body)$/;"	f
plug_server	deps/plug/lib/plug/upload.ex	/^  defp plug_server do$/;"	f
post	deps/plug/lib/plug/router.ex	/^  defmacro post(path, options, contents \\\\ []) do$/;"	a
prefix	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro prefix(path) do$/;"	a
present	deps/maru/lib/maru/helpers/response.ex	/^  defmacro present(key, payload, opts) do$/;"	a
present	deps/maru/lib/maru/helpers/response.ex	/^  defmacro present(payload, opts) do$/;"	a
pretty	deps/poison/lib/poison/encoder.ex	/^      defp pretty(options) do$/;"	f
project	deps/maru/mix.exs	/^  def project do$/;"	f
project	deps/plug/mix.exs	/^  def project do$/;"	f
project	deps/poison/mix.exs	/^  def project do$/;"	f
project	mix.exs	/^  def project do$/;"	f
prune	deps/plug/lib/plug/conn/query.ex	/^  defp prune([?&|t]), do: t$/;"	f
prune	deps/plug/lib/plug/conn/query.ex	/^  defp prune([]), do: []$/;"	f
put	deps/plug/lib/plug/router.ex	/^  defmacro put(path, options, contents \\\\ []) do$/;"	a
put	deps/plug/lib/plug/session/cookie.ex	/^  def put(conn, _sid, term, opts) do$/;"	f
put	deps/plug/lib/plug/session/ets.ex	/^  def put(_conn, nil, data, table) do$/;"	f
put	deps/plug/lib/plug/session/ets.ex	/^  def put(_conn, sid, data, table) do$/;"	f
put	deps/plug/lib/plug/session/store.ex	/^  defcallback put(Plug.Conn.t, sid, any, Plug.opts) :: cookie$/;"	c
put_cache_header	deps/plug/lib/plug/static.ex	/^  defp put_cache_header(%Conn{query_string: "vsn=" <> _} = conn, qs_cache, _et_cache, _file_info)$/;"	f
put_cache_header	deps/plug/lib/plug/static.ex	/^  defp put_cache_header(conn, _, _, _) do$/;"	f
put_cache_header	deps/plug/lib/plug/static.ex	/^  defp put_cache_header(conn, _qs_cache, et_cache, file_info) when is_binary(et_cache) do$/;"	f
put_cookie	deps/plug/lib/plug/session.ex	/^  defp put_cookie(value, conn, %{cookie_opts: cookie_opts, key: key}),$/;"	f
put_hsts_header	deps/plug/lib/plug/ssl.ex	/^  defp put_hsts_header(conn, _), do: conn$/;"	f
put_hsts_header	deps/plug/lib/plug/ssl.ex	/^  defp put_hsts_header(conn, hsts_header) when is_binary(hsts_header) do$/;"	f
put_new	deps/plug/lib/plug/session/ets.ex	/^  defp put_new(data, table, counter \\\\ 0)$/;"	f
put_present	deps/maru/lib/maru/helpers/response.ex	/^  def put_present(conn, key, payload, opts) do$/;"	f
put_present	deps/maru/lib/maru/helpers/response.ex	/^  def put_present(conn, payload, opts) do$/;"	f
put_private	deps/plug/lib/plug/conn.ex	/^  def put_private(%Conn{private: private} = conn, key, value) when is_atom(key) do$/;"	f
put_req_cookie	deps/plug/lib/plug/test.ex	/^  def put_req_cookie(conn, key, value) when is_binary(key) and is_binary(value) do$/;"	f
put_req_header	deps/plug/lib/plug/conn.ex	/^  def put_req_header(%Conn{req_headers: headers} = conn, key, value) when$/;"	f
put_req_header	deps/plug/lib/plug/conn.ex	/^  def put_req_header(%Conn{state: :sent}, _key, _value) do$/;"	f
put_resp_content_type	deps/plug/lib/plug/conn.ex	/^  def put_resp_content_type(conn, content_type, charset \\\\ "utf-8")$/;"	f
put_resp_content_type	deps/plug/lib/plug/conn.ex	/^  def put_resp_content_type(conn, content_type, charset) when$/;"	f
put_resp_content_type	deps/plug/lib/plug/conn.ex	/^  def put_resp_content_type(conn, content_type, nil) when is_binary(content_type) do$/;"	f
put_resp_cookie	deps/plug/lib/plug/conn.ex	/^  def put_resp_cookie(%Conn{resp_cookies: resp_cookies, scheme: scheme} = conn, key, value, opts \\\\ []) when$/;"	f
put_resp_header	deps/plug/lib/plug/conn.ex	/^  def put_resp_header(%Conn{resp_headers: headers} = conn, key, value) when$/;"	f
put_resp_header	deps/plug/lib/plug/conn.ex	/^  def put_resp_header(%Conn{state: :sent}, _key, _value) do$/;"	f
put_secret_key_base	deps/plug/lib/plug/session/cookie.ex	/^      def put_secret_key_base(conn, _) do$/;"	f
put_session	deps/plug/lib/plug/conn.ex	/^  def put_session(%Conn{state: state}, _key, _value) when not state in @unsent,$/;"	f
put_session	deps/plug/lib/plug/conn.ex	/^  def put_session(conn, key, value) do$/;"	f
put_session	deps/plug/lib/plug/conn.ex	/^  defp put_session(conn, fun) do$/;"	f
put_session	deps/plug/lib/plug/session.ex	/^  defp put_session(sid, conn, %{store: store, store_config: store_config}),$/;"	f
put_ssl_file	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp put_ssl_file(cowboy_options, key, value) do$/;"	f
put_status	deps/plug/lib/plug/conn.ex	/^  def put_status(%Conn{state: :sent}, _status),$/;"	f
put_status	deps/plug/lib/plug/conn.ex	/^  def put_status(%Conn{} = conn, nil),$/;"	f
put_status	deps/plug/lib/plug/conn.ex	/^  def put_status(%Conn{} = conn, status),$/;"	f
qs	deps/plug/lib/plug/ssl.ex	/^  defp qs(""), do: ""$/;"	f
qs	deps/plug/lib/plug/ssl.ex	/^  defp qs(qs), do: "?" <> qs$/;"	f
quote_if_buffer	deps/plug/lib/plug/router/utils.ex	/^  defp quote_if_buffer(identifier, "", context, _fun) do$/;"	f
quote_if_buffer	deps/plug/lib/plug/router/utils.ex	/^  defp quote_if_buffer(identifier, _buffer, context, fun) do$/;"	f
quote_plug	deps/plug/lib/plug/builder.ex	/^  defp quote_plug({plug_type, plug, opts, guards}, acc, env, builder_opts) do$/;"	f
quote_plug_call	deps/plug/lib/plug/builder.ex	/^  defp quote_plug_call(:function, plug, opts) do$/;"	f
quote_plug_call	deps/plug/lib/plug/builder.ex	/^  defp quote_plug_call(:module, plug, opts) do$/;"	f
quoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp quoted_token(<<>>, _acc),$/;"	f
quoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp quoted_token(<<?", t :: binary>>, acc),$/;"	f
quoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp quoted_token(<<?\\\\, h, t :: binary>>, acc),$/;"	f
quoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp quoted_token(<<h, t :: binary>>, acc),$/;"	f
raise_missing_parsers	deps/plug/lib/plug/parsers.ex	/^  defp raise_missing_parsers do$/;"	f
random_file	deps/plug/lib/plug/upload.ex	/^  def random_file(prefix) do$/;"	f
random_file!	deps/plug/lib/plug/upload.ex	/^  def random_file!(prefix) do$/;"	f
read_body	deps/plug/lib/plug/conn.ex	/^  def read_body(%Conn{adapter: {adapter, state}} = conn, opts \\\\ []) do$/;"	f
read_req_body	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def read_req_body(req, opts \\\\ []) do$/;"	f
read_req_body	deps/plug/lib/plug/adapters/test/conn.ex	/^  def read_req_body(%{req_body: body} = state, opts \\\\ []) do$/;"	f
read_req_body	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback read_req_body(payload, options :: Keyword.t) ::$/;"	c
receive_resp	deps/plug/lib/plug/test.ex	/^  defp receive_resp(ref) do$/;"	f
recycle_cookies	deps/plug/lib/plug/test.ex	/^  def recycle_cookies(new_conn, old_conn) do$/;"	f
redirect	deps/maru/lib/maru/helpers/response.ex	/^  defmacro redirect(url) do$/;"	a
redirect	deps/maru/lib/maru/helpers/response.ex	/^  defmacro redirect(url, permanent: true) do$/;"	a
redirect_to_https	deps/plug/lib/plug/ssl.ex	/^  defp redirect_to_https(%Conn{host: host} = conn, custom_host) do$/;"	f
reduce	deps/plug/lib/plug/parsers.ex	/^  defp reduce(conn, [], type, subtype, _headers, opts) do$/;"	f
reduce	deps/plug/lib/plug/parsers.ex	/^  defp reduce(conn, [h|t], type, subtype, headers, opts) do$/;"	f
register_before_send	deps/plug/lib/plug/conn.ex	/^  def register_before_send(%Conn{before_send: before_send} = conn, callback)$/;"	f
register_before_send	deps/plug/lib/plug/conn.ex	/^  def register_before_send(%Conn{state: state}, _callback)$/;"	f
regular_file_info	deps/plug/lib/plug/static.ex	/^  defp regular_file_info(path) do$/;"	f
render	deps/plug/lib/plug/debugger.ex	/^  def render(conn, kind, reason, stack, opts) do$/;"	f
request_info	deps/plug/lib/plug/adapters/translator.ex	/^  defp request_info(%Plug.Conn{method: method, query_string: query_string} = conn) do$/;"	f
requires	deps/maru/lib/maru/builder/params.ex	/^  defmacro requires(attr_name) do$/;"	a
requires	deps/maru/lib/maru/builder/params.ex	/^  defmacro requires(attr_name, [do: block]) do$/;"	a
requires	deps/maru/lib/maru/builder/params.ex	/^  defmacro requires(attr_name, options) do$/;"	a
requires	deps/maru/lib/maru/builder/params.ex	/^  defmacro requires(attr_name, options, [do: block]) do$/;"	a
reraise	deps/plug/lib/plug/conn/wrapper_error.ex	/^  def reraise(_conn, :error, %__MODULE__{stack: stack} = reason) do$/;"	f
reraise	deps/plug/lib/plug/conn/wrapper_error.ex	/^  def reraise(conn, kind, reason) do$/;"	f
rescue_from	deps/maru/lib/maru/builder/exceptions.ex	/^  defmacro rescue_from(:all, [as: error_var], [do: block]) do$/;"	a
rescue_from	deps/maru/lib/maru/builder/exceptions.ex	/^  defmacro rescue_from(:all, [do: block]) do$/;"	a
rescue_from	deps/maru/lib/maru/builder/exceptions.ex	/^  defmacro rescue_from(error, [as: error_var], [do: block]) do$/;"	a
rescue_from	deps/maru/lib/maru/builder/exceptions.ex	/^  defmacro rescue_from(error, [do: block]) do$/;"	a
resp	deps/plug/lib/plug/conn.ex	/^  def resp(%Conn{state: state}, status, _body)$/;"	f
resp	deps/plug/lib/plug/conn.ex	/^  def resp(%Conn{} = conn, status, body)$/;"	f
resp	deps/plug/lib/plug/conn.ex	/^  def resp(%Conn{}, _status, nil) do$/;"	f
resp_body	deps/maru/lib/maru/response.ex	/^  def resp_body(resp) do$/;"	f
resp_body	deps/maru/lib/maru/response.ex	/^  def resp_body(resp)$/;"	f
rewrite_on	deps/plug/lib/plug/ssl.ex	/^  defp rewrite_on(conn, rewrites) do$/;"	f
rfc2822	deps/plug/lib/plug/conn/cookies.ex	/^  defp rfc2822({{year, month, day} = date, {hour, minute, second}}) do$/;"	f
route_param	deps/maru/lib/maru/builder/namespaces.ex	/^  defmacro route_param(param, [do: block]) do$/;"	a
run	deps/maru/lib/mix/tasks/routers.ex	/^  def run(_) do$/;"	f
run	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp run(scheme, plug, opts, cowboy_options) do$/;"	f
run_before_send	deps/plug/lib/plug/conn.ex	/^  defp run_before_send(%Conn{before_send: before_send} = conn, new) do$/;"	f
scheme	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp scheme(:ssl), do: :https$/;"	f
scheme	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp scheme(:tcp), do: :http$/;"	f
secure_compare	deps/plug/lib/plug/crypto.ex	/^  def secure_compare(left, right) do$/;"	f
secure_compare	deps/plug/lib/plug/crypto.ex	/^  defp secure_compare(<<>>, <<>>, acc) do$/;"	f
secure_compare	deps/plug/lib/plug/crypto.ex	/^  defp secure_compare(<<x, left :: binary>>, <<y, right :: binary>>, acc) do$/;"	f
segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp segment_match("*" <> argument, buffer, context) do$/;"	f
segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp segment_match(":" <> argument, buffer, context) do$/;"	f
segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp segment_match(<<>>, buffer, _context) do$/;"	f
segment_match	deps/plug/lib/plug/router/utils.ex	/^  defp segment_match(<<h, t::binary>>, buffer, context) do$/;"	f
send_chunked	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def send_chunked(req, status, headers) do$/;"	f
send_chunked	deps/plug/lib/plug/adapters/test/conn.ex	/^  def send_chunked(state, _status, _headers),$/;"	f
send_chunked	deps/plug/lib/plug/conn.ex	/^  def send_chunked(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status) do$/;"	f
send_chunked	deps/plug/lib/plug/conn.ex	/^  def send_chunked(%Conn{state: state}, status)$/;"	f
send_chunked	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback send_chunked(payload, Conn.status, Conn.headers) ::$/;"	c
send_file	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def send_file(req, status, headers, path, offset, length) do$/;"	f
send_file	deps/plug/lib/plug/adapters/test/conn.ex	/^  def send_file(%{method: "HEAD"} = state, status, headers, _path, _offset, _length) do$/;"	f
send_file	deps/plug/lib/plug/adapters/test/conn.ex	/^  def send_file(state, status, headers, path, offset, length) do$/;"	f
send_file	deps/plug/lib/plug/conn.ex	/^  def send_file(%Conn{adapter: {adapter, payload}, owner: owner} = conn, status, file, offset, length)$/;"	f
send_file	deps/plug/lib/plug/conn.ex	/^  def send_file(%Conn{state: state}, status, _file, _offset, _length)$/;"	f
send_file	deps/plug/lib/plug/conn.ex	/^  def send_file(conn, status, file, offset \\\\ 0, length  \\\\ :all)$/;"	f
send_file	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback send_file(payload, Conn.status, Conn.headers, file :: binary,$/;"	c
send_resp	deps/maru/lib/maru/router/endpoint.ex	/^  def send_resp(_, %Plug.Conn{private: %{maru_present: present}}=conn) do$/;"	f
send_resp	deps/maru/lib/maru/router/endpoint.ex	/^  def send_resp(_, %Plug.Conn{}=conn) do$/;"	f
send_resp	deps/maru/lib/maru/router/endpoint.ex	/^  def send_resp(conn, resp) do$/;"	f
send_resp	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  def send_resp(req, status, headers, body) do$/;"	f
send_resp	deps/plug/lib/plug/adapters/test/conn.ex	/^  def send_resp(%{method: "HEAD"} = state, status, headers, _body) do$/;"	f
send_resp	deps/plug/lib/plug/adapters/test/conn.ex	/^  def send_resp(state, status, headers, body) do$/;"	f
send_resp	deps/plug/lib/plug/conn.ex	/^  def send_resp(%Conn{adapter: {adapter, payload}, state: :set, owner: owner} = conn) do$/;"	f
send_resp	deps/plug/lib/plug/conn.ex	/^  def send_resp(%Conn{state: :unset}) do$/;"	f
send_resp	deps/plug/lib/plug/conn.ex	/^  def send_resp(%Conn{} = conn, status, body) do$/;"	f
send_resp	deps/plug/lib/plug/conn.ex	/^  def send_resp(%Conn{}) do$/;"	f
send_resp	deps/plug/lib/plug/conn.ex	/^  def send_resp(conn)$/;"	f
send_resp	deps/plug/lib/plug/conn/adapter.ex	/^  defcallback send_resp(payload, Conn.status, Conn.headers, Conn.body) ::$/;"	c
sent_resp	deps/plug/lib/plug/test.ex	/^  def sent_resp(%Conn{adapter: {Plug.Adapters.Test.Conn, %{ref: ref}}}) do$/;"	f
seq	deps/poison/lib/poison/encoder.ex	/^  defp seq(char) do$/;"	f
serve_static	deps/plug/lib/plug/static.ex	/^  defp serve_static({:error, conn}, _segments, _gzip, _qs_cache, _et_cache, _headers) do$/;"	f
serve_static	deps/plug/lib/plug/static.ex	/^  defp serve_static({:ok, conn, file_info, path}, segments, gzip, qs_cache, et_cache, headers) do$/;"	f
server_config	deps/maru/lib/maru/config.ex	/^  def server_config(module) do$/;"	f
server_info	deps/plug/lib/plug/adapters/translator.ex	/^  defp server_info(%Plug.Conn{host: host, port: port, scheme: scheme}) do$/;"	f
servers	deps/maru/lib/maru/config.ex	/^  def servers do$/;"	f
session_key	deps/plug/lib/plug/conn.ex	/^  defp session_key(atom) when is_atom(atom), do: Atom.to_string(atom)$/;"	f
session_key	deps/plug/lib/plug/conn.ex	/^  defp session_key(binary) when is_binary(binary), do: binary$/;"	f
set_request_id	deps/plug/lib/plug/request_id.ex	/^  defp set_request_id({conn, request_id}, header) do$/;"	f
showdown	lib/leanpoker_elixir/player.ex	/^  def showdown(game_state) do$/;"	f
shutdown	deps/plug/lib/plug/adapters/cowboy.ex	/^  def shutdown(ref) do$/;"	f
sign	deps/plug/lib/plug/crypto/message_verifier.ex	/^  def sign(binary, secret) when is_binary(binary) and is_binary(secret) do$/;"	f
skip_csrf_protection?	deps/plug/lib/plug/csrf_protection.ex	/^  defp skip_csrf_protection?(%Plug.Conn{private: %{plug_skip_csrf_protection: true}}), do: true$/;"	f
skip_csrf_protection?	deps/plug/lib/plug/csrf_protection.ex	/^  defp skip_csrf_protection?(%Plug.Conn{}), do: false$/;"	f
skip_whitespace	deps/poison/lib/poison/parser.ex	/^  defp skip_whitespace(<<char>> <> rest) when char in '\\s\\n\\t\\r' do$/;"	f
skip_whitespace	deps/poison/lib/poison/parser.ex	/^  defp skip_whitespace(string), do: string$/;"	f
spaces	deps/poison/lib/poison/encoder.ex	/^      defp spaces(count) do$/;"	f
split	deps/maru/lib/maru/router/path.ex	/^  def split(_path), do: raise "path should be Atom or String"$/;"	f
split	deps/maru/lib/maru/router/path.ex	/^  def split(path) when is_atom(path), do: [path |> to_string]$/;"	f
split	deps/maru/lib/maru/router/path.ex	/^  def split(path) when is_binary(path) do$/;"	f
split	deps/plug/lib/plug/router/utils.ex	/^  def split(bin) do$/;"	f
split_param_context	deps/maru/lib/maru/router/endpoint.ex	/^  defp split_param_context([], _group, {left, right}), do: {Enum.reverse(left), Enum.reverse(right)}$/;"	f
split_param_context	deps/maru/lib/maru/router/endpoint.ex	/^  defp split_param_context([p|t], group, {left, right}) do$/;"	f
split_param_context	deps/maru/lib/maru/router/endpoint.ex	/^  defp split_param_context(list, group) do$/;"	f
split_path	deps/plug/lib/plug/adapters/cowboy/conn.ex	/^  defp split_path(path) do$/;"	f
split_path	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp split_path(path) do$/;"	f
start	deps/maru/lib/maru.ex	/^  def start(_type, _args) do$/;"	f
start	deps/plug/lib/plug.ex	/^  def start(_type, _args) do$/;"	f
start_link	deps/plug/lib/plug/supervisor.ex	/^  def start_link() do$/;"	f
start_link	deps/plug/lib/plug/upload.ex	/^  def start_link() do$/;"	f
status	deps/maru/lib/maru/helpers/response.ex	/^  defmacro status(value) do$/;"	a
status	deps/plug/lib/plug/error_handler.ex	/^  defp status(:error, error),  do: Plug.Exception.status(error)$/;"	f
status	deps/plug/lib/plug/error_handler.ex	/^  defp status(:exit, _exit),   do: 500$/;"	f
status	deps/plug/lib/plug/error_handler.ex	/^  defp status(:throw, _throw), do: 500$/;"	f
status	deps/plug/lib/plug/exceptions.ex	/^  def status(%{plug_status: status}) when is_integer(status), do: status$/;"	f
status	deps/plug/lib/plug/exceptions.ex	/^  def status(_), do: 500$/;"	f
status	deps/plug/lib/plug/exceptions.ex	/^  def status(exception)$/;"	f
stopper	deps/plug/lib/plug/builder.ex	/^        def stopper(conn, _opts) do$/;"	f
string_chunk_size	deps/poison/lib/poison/parser.ex	/^  defp string_chunk_size("\\"" <> _, acc), do: acc$/;"	f
string_chunk_size	deps/poison/lib/poison/parser.ex	/^  defp string_chunk_size("\\\\" <> _, acc), do: acc$/;"	f
string_chunk_size	deps/poison/lib/poison/parser.ex	/^  defp string_chunk_size(<<char>> <> rest, acc) when char < 0x80 do$/;"	f
string_chunk_size	deps/poison/lib/poison/parser.ex	/^  defp string_chunk_size(<<codepoint :: utf8>> <> rest, acc) do$/;"	f
string_chunk_size	deps/poison/lib/poison/parser.ex	/^  defp string_chunk_size(other, _), do: syntax_error(other)$/;"	f
string_codepoint_size	deps/poison/lib/poison/parser.ex	/^  defp string_codepoint_size(_),                                  do: 4$/;"	f
string_codepoint_size	deps/poison/lib/poison/parser.ex	/^  defp string_codepoint_size(codepoint) when codepoint < 0x10000, do: 3$/;"	f
string_codepoint_size	deps/poison/lib/poison/parser.ex	/^  defp string_codepoint_size(codepoint) when codepoint < 0x800,   do: 2$/;"	f
string_continue	deps/poison/lib/poison/parser.ex	/^  defp string_continue("", _), do: throw(:invalid)$/;"	f
string_continue	deps/poison/lib/poison/parser.ex	/^  defp string_continue("\\"" <> rest, acc) do$/;"	f
string_continue	deps/poison/lib/poison/parser.ex	/^  defp string_continue("\\\\" <> rest, acc) do$/;"	f
string_continue	deps/poison/lib/poison/parser.ex	/^  defp string_continue(string, acc) do$/;"	f
string_escape	deps/poison/lib/poison/parser.ex	/^    defp string_escape(<<unquote(seq)>> <> rest, acc) do$/;"	f
string_escape	deps/poison/lib/poison/parser.ex	/^  defp string_escape(<<?u, a1, b1, c1, d1, "\\\\u", a2, b2, c2, d2>> <> rest, acc)$/;"	f
string_escape	deps/poison/lib/poison/parser.ex	/^  defp string_escape(<<?u, seq :: binary-size(4)>> <> rest, acc) do$/;"	f
string_escape	deps/poison/lib/poison/parser.ex	/^  defp string_escape(other, _), do: syntax_error(other)$/;"	f
stringify_kv	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_kv({k, v}),$/;"	f
stringify_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_params(%{__struct__: mod} = struct) when is_atom(mod),$/;"	f
stringify_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_params(%{} = params),$/;"	f
stringify_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_params([_|_] = params),$/;"	f
stringify_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_params([{_, _}|_] = params),$/;"	f
stringify_params	deps/plug/lib/plug/adapters/test/conn.ex	/^  defp stringify_params(other),$/;"	f
strip_spaces	deps/plug/lib/plug/conn/utils.ex	/^  defp strip_spaces("\\r\\n" <> t),$/;"	f
strip_spaces	deps/plug/lib/plug/conn/utils.ex	/^  defp strip_spaces(<<h, t :: binary>>) when h in [?\\s, ?\\t],$/;"	f
strip_spaces	deps/plug/lib/plug/conn/utils.ex	/^  defp strip_spaces(t),$/;"	f
subset	deps/plug/lib/plug/static.ex	/^  defp subset([], actual),$/;"	f
subset	deps/plug/lib/plug/static.ex	/^  defp subset([h|expected], [h|actual]),$/;"	f
subset	deps/plug/lib/plug/static.ex	/^  defp subset(_, _),$/;"	f
syntax_error	deps/poison/lib/poison/parser.ex	/^  defp syntax_error(<<token :: utf8>> <> _) do$/;"	f
syntax_error	deps/poison/lib/poison/parser.ex	/^  defp syntax_error(_) do$/;"	f
terminate	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  defp terminate(reason, req, stack) do$/;"	f
to_args	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp to_args(all_opts) do$/;"	f
to_char_list	deps/plug/lib/plug/adapters/cowboy.ex	/^  defp to_char_list(cowboy_options, key) do$/;"	f
to_port	deps/maru/lib/maru.ex	/^  defp to_port(nil),                        do: nil$/;"	f
to_port	deps/maru/lib/maru.ex	/^  defp to_port(port) when is_binary(port),  do: port |> String.to_integer$/;"	f
to_port	deps/maru/lib/maru.ex	/^  defp to_port(port) when is_integer(port), do: port$/;"	f
to_port	deps/maru/lib/maru.ex	/^  defp to_port({:system, env_var}),         do: System.get_env(env_var) |> to_port$/;"	f
token	deps/plug/lib/plug/conn/utils.ex	/^  def token(""),$/;"	f
token	deps/plug/lib/plug/conn/utils.ex	/^  def token(<<?", quoted :: binary>>),$/;"	f
token	deps/plug/lib/plug/conn/utils.ex	/^  def token(token),$/;"	f
topological_sort	deps/maru/lib/maru/builder/routers.ex	/^  defp topological_sort([], r), do: r |> Enum.reverse$/;"	f
topological_sort	deps/maru/lib/maru/builder/routers.ex	/^  defp topological_sort([{_, nil}=h | t], r) do$/;"	f
topological_sort	deps/maru/lib/maru/builder/routers.ex	/^  defp topological_sort([{_, opts}=h | t], r) do$/;"	f
transform	deps/poison/lib/poison/decoder.ex	/^  defp transform(value, _keys, _as, _options) do$/;"	f
transform	deps/poison/lib/poison/decoder.ex	/^  defp transform(value, keys, [as], options) do$/;"	f
transform	deps/poison/lib/poison/decoder.ex	/^  defp transform(value, keys, as, options) when is_atom(as) do$/;"	f
transform	deps/poison/lib/poison/decoder.ex	/^  defp transform(value, keys, as, options) when is_map(as) do$/;"	f
transform_map	deps/poison/lib/poison/decoder.ex	/^  defp transform_map(value, keys, as, options) do$/;"	f
transform_struct	deps/poison/lib/poison/decoder.ex	/^  defp transform_struct(value, _keys, as, options) do$/;"	f
transform_struct	deps/poison/lib/poison/decoder.ex	/^  defp transform_struct(value, keys, as, options) when keys in [:atoms, :atoms!] do$/;"	f
translate	deps/plug/lib/plug/adapters/translator.ex	/^  def translate(_min_level, _level, _kind, _data) do$/;"	f
translate	deps/plug/lib/plug/adapters/translator.ex	/^  def translate(min_level, :error, :format,$/;"	f
translate_ranch	deps/plug/lib/plug/adapters/translator.ex	/^  defp translate_ranch(_min_level, ref, protocol, pid, reason) do$/;"	f
translate_ranch	deps/plug/lib/plug/adapters/translator.ex	/^  defp translate_ranch(min_level, _ref, :cowboy_protocol, pid,$/;"	f
traversal_module	deps/maru/lib/maru/builder/routers.ex	/^  defp traversal_module(module) do$/;"	f
trim_secret	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  defp trim_secret(secret) do$/;"	f
try_extend	deps/maru/lib/maru/plugs/extend.ex	/^  defp try_extend(conn_orig, router, extend) do$/;"	f
type	deps/plug/lib/plug/mime.ex	/^    def type(unquote(ext)), do: unquote(type)$/;"	f
type	deps/plug/lib/plug/mime.ex	/^  def type(_ext), do: @default_type$/;"	f
type	deps/plug/lib/plug/mime.ex	/^  def type(file_extension)$/;"	f
unmasked_csrf_token	deps/plug/lib/plug/csrf_protection.ex	/^  defp unmasked_csrf_token do$/;"	f
unpad_message	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  defp unpad_message(msg) do$/;"	f
unquote	deps/maru/lib/maru/builder/methods.ex	/^    defmacro unquote(method)(path \\\\ "", [do: block]) do$/;"	a
unquote	deps/maru/lib/maru/builder/namespaces.ex	/^    defmacro unquote(namespace)([do: block]), do: block$/;"	a
unquote	deps/maru/lib/maru/builder/namespaces.ex	/^    defmacro unquote(namespace)(path, [do: block]) do$/;"	a
unquote	deps/maru/lib/maru/builder/params.ex	/^      defmacro unquote(action)(attr_names) do$/;"	a
unquoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp unquoted_token("\\r\\n" <> t, acc),$/;"	f
unquoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp unquoted_token(<<>>, acc),$/;"	f
unquoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp unquoted_token(<<h, _ :: binary>>, _acc) when h in @specials or h < 32 or h === 127,$/;"	f
unquoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp unquoted_token(<<h, t :: binary>>, acc) when h in @space,$/;"	f
unquoted_token	deps/plug/lib/plug/conn/utils.ex	/^  defp unquoted_token(<<h, t :: binary>>, acc),$/;"	f
update_cookies	deps/plug/lib/plug/conn.ex	/^  defp update_cookies(%Conn{cookies: %Unfetched{}} = conn, _fun),$/;"	f
update_cookies	deps/plug/lib/plug/conn.ex	/^  defp update_cookies(%Conn{cookies: cookies} = conn, fun),$/;"	f
update_cookies	deps/plug/lib/plug/conn.ex	/^  defp update_cookies(%Conn{state: :sent}, _fun),$/;"	f
update_req_header	deps/plug/lib/plug/conn.ex	/^  def update_req_header(%Conn{state: :sent}, _key, _initial, _fun) do$/;"	f
update_req_header	deps/plug/lib/plug/conn.ex	/^  def update_req_header(%Conn{} = conn, key, initial, fun) when$/;"	f
update_resp_header	deps/plug/lib/plug/conn.ex	/^  def update_resp_header(%Conn{state: :sent}, _key, _initial, _fun) do$/;"	f
update_resp_header	deps/plug/lib/plug/conn.ex	/^  def update_resp_header(%Conn{} = conn, key, initial, fun) when$/;"	f
upgrade	deps/plug/lib/plug/adapters/cowboy/handler.ex	/^  def upgrade(req, env, __MODULE__, {transport, plug, opts}) do$/;"	f
upper_camel_case	deps/maru/lib/maru/utils.ex	/^  def upper_camel_case(s) do$/;"	f
url	deps/plug/lib/plug/debugger.ex	/^  defp url(%Plug.Conn{scheme: scheme, host: host, port: port} = conn), do:$/;"	f
use	deps/maru/lib/maru/builder/params.ex	/^  defmacro use(param) when is_atom(param) do$/;"	a
use	deps/maru/lib/maru/builder/params.ex	/^  defmacro use(params) do$/;"	a
valid?	deps/plug/lib/plug/mime.ex	/^  def valid?(type) do$/;"	f
valid_csrf_token?	deps/plug/lib/plug/csrf_protection.ex	/^  defp valid_csrf_token?(<<csrf_token::@encoded_token_size-binary>>,$/;"	f
valid_csrf_token?	deps/plug/lib/plug/csrf_protection.ex	/^  defp valid_csrf_token?(_csrf_token, _user_token), do: false$/;"	f
valid_header_key?	deps/plug/lib/plug/conn.ex	/^  defp valid_header_key?(<<>>), do: true$/;"	f
valid_header_key?	deps/plug/lib/plug/conn.ex	/^  defp valid_header_key?(<<_, t::binary>>), do: valid_header_key?(t)$/;"	f
valid_header_key?	deps/plug/lib/plug/conn.ex	/^  defp valid_header_key?(<<h, _::binary>>) when h in ?A..?Z, do: false$/;"	f
valid_header_key?	deps/plug/lib/plug/conn.ex	/^  defp valid_header_key?(_), do: false$/;"	f
valid_request_id?	deps/plug/lib/plug/request_id.ex	/^  defp valid_request_id?(s), do: byte_size(s) in 20..200$/;"	f
validate!	deps/maru/lib/maru/validations.ex	/^    def validate!(attr_names, params) do$/;"	f
validate_header_key!	deps/plug/lib/plug/conn.ex	/^  defp validate_header_key!(key) do$/;"	f
validate_param!	deps/maru/lib/maru/validations.ex	/^    def validate_param!(_, _, true), do: true$/;"	f
validate_param!	deps/maru/lib/maru/validations.ex	/^    def validate_param!(attr_name, value, false) do$/;"	f
validate_param!	deps/maru/lib/maru/validations.ex	/^    def validate_param!(attr_name, value, option) do$/;"	f
validate_params	deps/maru/lib/maru/router/endpoint.ex	/^  def validate_params([%Param{attr_name: attr_name, group: group, nested: false}=p|t], params, result) do$/;"	f
validate_params	deps/maru/lib/maru/router/endpoint.ex	/^  def validate_params([%Param{attr_name: attr_name, group: group, parser: Maru.ParamType.List}=p|t], params, result) do$/;"	f
validate_params	deps/maru/lib/maru/router/endpoint.ex	/^  def validate_params([%Param{attr_name: attr_name, group: group, parser: Maru.ParamType.Map}=p|t], params, result) do$/;"	f
validate_params	deps/maru/lib/maru/router/endpoint.ex	/^  def validate_params([%Validator{action: action, attr_names: attr_names, group: group}|t], params, result) do$/;"	f
validate_params	deps/maru/lib/maru/router/endpoint.ex	/^  def validate_params([], _params, result), do: result$/;"	f
validate_secret_key_base	deps/plug/lib/plug/session/cookie.ex	/^  defp validate_secret_key_base(nil), do:$/;"	f
validate_secret_key_base	deps/plug/lib/plug/session/cookie.ex	/^  defp validate_secret_key_base(secret_key_base) when byte_size(secret_key_base) < 64, do:$/;"	f
validate_secret_key_base	deps/plug/lib/plug/session/cookie.ex	/^  defp validate_secret_key_base(secret_key_base), do:$/;"	f
validate_utf8!	deps/plug/lib/plug/conn/utils.ex	/^  def validate_utf8!(<<>>, _context) do$/;"	f
validate_utf8!	deps/plug/lib/plug/conn/utils.ex	/^  def validate_utf8!(<<_ :: utf8, t :: binary>>, context) do$/;"	f
validate_utf8!	deps/plug/lib/plug/conn/utils.ex	/^  def validate_utf8!(<<h, _ :: binary>>, context) do$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("[" <> rest, keys),      do: array_values(skip_whitespace(rest), keys, [])$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("\\"" <> rest, _keys),    do: string_continue(rest, [])$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("false" <> rest, _keys), do: {false, rest}$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("null" <> rest, _keys),  do: {nil, rest}$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("true" <> rest, _keys),  do: {true, rest}$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value("{" <> rest, keys),      do: object_pairs(skip_whitespace(rest), keys, [])$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value(<<char, _ :: binary>> = string, _keys) when char in '-0123456789' do$/;"	f
value	deps/poison/lib/poison/parser.ex	/^  defp value(other, _keys), do: syntax_error(other)$/;"	f
verified_request?	deps/plug/lib/plug/csrf_protection.ex	/^  defp verified_request?(conn, csrf_token) do$/;"	f
verify	deps/plug/lib/plug/crypto/message_verifier.ex	/^  def verify(binary, secret) when is_binary(binary) and is_binary(secret) do$/;"	f
verify_and_decrypt	deps/plug/lib/plug/crypto/message_encryptor.ex	/^  def verify_and_decrypt(encrypted, secret, sign_secret, cipher \\\\ :aes_cbc256)$/;"	f
version	deps/maru/lib/maru.ex	/^  def version do$/;"	f
version	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro version(v) do$/;"	a
version	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro version(v, [do: block]) do$/;"	a
version	deps/maru/lib/maru/builder/dsls.ex	/^  defmacro version(v, [{:extend, _}, {:at, _} | _]=opts) do$/;"	a
version	lib/leanpoker_elixir/player.ex	/^  def version, do: @version$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(1), do: "Mon"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(2), do: "Tue"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(3), do: "Wed"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(4), do: "Thu"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(5), do: "Fri"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(6), do: "Sat"$/;"	f
weekday_name	deps/plug/lib/plug/conn/cookies.ex	/^  defp weekday_name(7), do: "Sun"$/;"	f
with_cache	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp with_cache(ets, key, fun) do$/;"	f
with_cache	deps/plug/lib/plug/crypto/key_generator.ex	/^  defp with_cache(nil, _key, fun), do: fun.()$/;"	f
with_line_number	deps/plug/lib/plug/debugger.ex	/^  defp with_line_number(lines, initial, highlight) do$/;"	f
write_tmp_dir	deps/plug/lib/plug/upload.ex	/^  defp write_tmp_dir(path) do$/;"	f
xhr?	deps/plug/lib/plug/csrf_protection.ex	/^  defp xhr?(conn) do$/;"	f
